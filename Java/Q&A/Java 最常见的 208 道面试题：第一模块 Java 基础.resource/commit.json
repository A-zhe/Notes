{"compress":true,"commitItems":[["052f9cc5-58c1-4eb8-889c-5ebf39dff54c",1563097511436,"## Java 最常见的 208 道面试题：第一模块答案\n\n王磊的博客 [Java团长](javascript:void(0);) _3月12日_\n\n![](https://mmbiz.qpic.cn/mmbiz_jpg/QCu849YTaIOib4Wgpnhw92q7t0o8IBe1ltNZ8nSmfR8yrrYoRziccwKhiceiabRzZibfRa2MUKhJRZ0F98IvzRCYaeQ/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n来源：王磊的博客\n\n* * *\n\n目前市面上的面试题存在两大问题：第一，题目太旧好久没有更新了，还都停留在 2010 年之前的状态；第二，近几年 JDK 更新和发布都很快，Java 的用法也变了不少，加上 Java 技术栈也加入了很多新的框架，比如 Spring Boot、Spring Cloud 等，但类似的面试题却极少。\n\n相比与这些问题，我的这 208 道面试题具备以下优点：\n\n1.  披沙拣金提炼出每个 Java 模块中最经典的面试题；\n\n2.  答案准确，每个题目都是我仔细校对过的；\n\n3.  接近最真实的企业面试，题目实用有效果；\n\n4.  难懂的题目，我加入了代码解析和原理分析。\n\n本篇是这 208 道题中，第一部分“Java 基础”模块的题和答案。\n\n### **Java 基础**\n\n**1\\. JDK 和 JRE 有什么区别？**\n\n*   JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\n\n*   JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n\n**2\\. == 和 equals 的区别是什么？**\n\n**== 解读**\n\n对于基本类型和引用类型 == 的作用效果是不同的，如下所示：\n\n*   基本类型：比较的是值是否相同；\n\n*   引用类型：比较的是引用是否相同；\n\n代码示例：\n\n```\nString x = \"string\";\n```\n\n代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。\n\n**equals 解读**\n\nequals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。\n\n首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：\n\n```\nclass Cat {\n```\n\n输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：\n\n```\npublic boolean equals(Object obj) {\n```\n\n原来 equals 本质上就是 ==。\n\n那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：\n\n```\nString s1 = new String(\"老王\");\n```\n\n同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：\n\n```\npublic boolean equals(Object anObject) {\n```\n\n原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。\n\n**总结** ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n**3\\. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？**\n\n不对，两个对象的 hashCode()相同，equals()不一定 true。\n\n代码示例：\n\n```\nString str1 = \"通话\";\n```\n\n执行的结果：\n\nstr1：1179395 | str2：1179395\n\nfalse\n\n代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n\n**4\\. final 在 java 中有什么作用？**\n\n*   final 修饰的类叫最终类，该类不能被继承。\n\n*   final 修饰的方法不能被重写。\n\n*   final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n**5\\. java 中的 Math.round(-1.5) 等于多少？**\n\n等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。\n\n**6\\. String 属于基础的数据类型吗？**\n\nString 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。\n\n**7\\. java 中操作字符串都有哪些类？它们之间有什么区别？**\n\n操作字符串的类有：String、StringBuffer、StringBuilder。\n\nString 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n\n**8\\. String str=\"i\"与 String str=new String(\"i\")一样吗？**\n\n不一样，因为内存的分配方式不一样。String str=\"i\"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(\"i\") 则会被分到堆内存中。\n\n**9\\. 如何将字符串反转？**\n\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n\n示例代码：\n\n```\n// StringBuffer reverse\n```\n\n**10\\. String 类的常用方法都有那些？**\n\n*   indexOf()：返回指定字符的索引。\n\n*   charAt()：返回指定索引处的字符。\n\n*   replace()：字符串替换。\n\n*   trim()：去除字符串两端空白。\n\n*   split()：分割字符串，返回一个分割后的字符串数组。\n\n*   getBytes()：返回字符串的 byte 类型数组。\n\n*   length()：返回字符串长度。\n\n*   toLowerCase()：将字符串转成小写字母。\n\n*   toUpperCase()：将字符串转成大写字符。\n\n*   substring()：截取字符串。\n\n*   equals()：字符串比较。\n\n**11\\. 抽象类必须要有抽象方法吗？**\n\n不需要，抽象类不一定非要有抽象方法。\n\n示例代码：\n\n```\nabstract class Cat {\n```\n\n上面代码，抽象类并没有抽象方法但完全可以正常运行。\n\n**12\\. 普通类和抽象类有哪些区别？**\n\n*   普通类不能包含抽象方法，抽象类可以包含抽象方法。\n\n*   抽象类不能直接实例化，普通类可以直接实例化。\n\n**13\\. 抽象类能使用 final 修饰吗？**\n\n不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIPT1PAKpMFkqYyedicsJQOufr2NcJQfeXG1tvNJPfMJ7kEZ79hJd1WoDCeSmzbGnqF8ofWsXth5veQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**14\\. 接口和抽象类有什么区别？**\n\n*   实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n\n*   构造函数：抽象类可以有构造函数；接口不能有。\n\n*   main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。\n\n*   实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n\n*   访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n**15\\. java 中 IO 流分为几种？**\n\n按功能来分：输入流（input）、输出流（output）。\n\n按类型来分：字节流和字符流。\n\n字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。\n\n**16\\. BIO、NIO、AIO 有什么区别？**\n\n*   BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\n\n*   NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\n*   AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n**17\\. Files的常用方法都有哪些？**\n\n*   Files.exists()：检测文件路径是否存在。\n\n*   Files.createFile()：创建文件。\n\n*   Files.createDirectory()：创建文件夹。\n\n*   Files.delete()：删除一个文件或目录。\n\n*   Files.copy()：复制文件。\n\n*   Files.move()：移动文件。\n\n*   Files.size()：查看文件个数。\n\n*   Files.read()：读取文件。\n\n*   Files.write()：写入文件。",[[1563097494862,["GJX@GJXAIOU",[[1,1015,"```\n"],[1,1035,"\n```"]],[1015,1035],[1043,1043]]],[1563097498130,["GJX@GJXAIOU",[[-1,1015,"```\nString x = \"string\";\n```"]],[1015,1043],[1015,1015]]],[1563097503672,["GJX@GJXAIOU",[[1,1015,"String x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true"]],[1015,1015],[1240,1240]]],[1563097521504,["GJX@GJXAIOU",[[1,1499,"    public Cat(String name) {\n        this.name = name;\n    }\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false\n"]],[1487,1498],[1811,1811]]],[1563097536675,["GJX@GJXAIOU",[[1,1874,"class Cat {\n    "],[-1,1881,"boolean equals(Object obj) {"],[1,1909,"Cat(String name) {\n        this.name = name;\n    }\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false"]],[1874,1909],[2198,2198]]],[1563097539202,["GJX@GJXAIOU",[[-1,1874,"class Cat {\n    "],[1,1897,"boolean equals(Object obj) {"],[-1,1897,"Cat(String name) {\n        this.name = name;\n    }\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false"]],[2198,2198],[1874,1909]]],[1563097548285,["GJX@GJXAIOU",[[1,1910,"    return (this == obj);\n}\n"]],[1874,1909],[1937,1937]]],[1563097562366,["GJX@GJXAIOU",[[1,2041,"String s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n"]],[2011,2040],[2113,2113]]],[1563097574404,["GJX@GJXAIOU",[[1,2206,"    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n"]],[2165,2205],[2720,2720]]],[1563097593018,["GJX@GJXAIOU",[[1,3032,"String str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\",  str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n"]],[3012,3031],[3180,3180]]],[1563097615881,["GJX@GJXAIOU",[[1,4362,"StringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n"]],[4338,4361],[4661,4661]]],[1563097631287,["GJX@GJXAIOU",[[1,5067,"    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n"]],[5046,5066],[5142,5142]]],[1563097644089,["GJX@GJXAIOU",[[-1,6222,"\n"]],[6222,6222],[6221,6221]]],[1563097645488,["GJX@GJXAIOU",[[-1,6251,"\n"]],[6251,6251],[6250,6250]]],[1563097646216,["GJX@GJXAIOU",[[-1,6286,"\n"]],[6286,6286],[6285,6285]]],[1563097647352,["GJX@GJXAIOU",[[-1,6316,"\n"]],[6316,6316],[6315,6315]]],[1563097647959,["GJX@GJXAIOU",[[-1,6339,"\n"]],[6339,6339],[6338,6338]]],[1563097648768,["GJX@GJXAIOU",[[-1,6362,"\n"]],[6362,6362],[6361,6361]]],[1563097649434,["GJX@GJXAIOU",[[-1,6387,"\n"]],[6387,6387],[6386,6386]]],[1563097650392,["GJX@GJXAIOU",[[-1,6410,"\n"]],[6410,6410],[6409,6409]]]],null,"GJX@GJXAIOU"],["020e1314-771b-43b4-8a58-32dc03cf13de",1563449636286,"## Java 最常见的 208 道面试题：第一模块答案\n\n王磊的博客 [Java团长](javascript:void(0);) _3月12日_\n\n![](https://mmbiz.qpic.cn/mmbiz_jpg/QCu849YTaIOib4Wgpnhw92q7t0o8IBe1ltNZ8nSmfR8yrrYoRziccwKhiceiabRzZibfRa2MUKhJRZ0F98IvzRCYaeQ/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n来源：王磊的博客\n\n* * *\n\n目前市面上的面试题存在两大问题：第一，题目太旧好久没有更新了，还都停留在 2010 年之前的状态；第二，近几年 JDK 更新和发布都很快，Java 的用法也变了不少，加上 Java 技术栈也加入了很多新的框架，比如 Spring Boot、Spring Cloud 等，但类似的面试题却极少。\n\n相比与这些问题，我的这 208 道面试题具备以下优点：\n\n1.  披沙拣金提炼出每个 Java 模块中最经典的面试题；\n\n2.  答案准确，每个题目都是我仔细校对过的；\n\n3.  接近最真实的企业面试，题目实用有效果；\n\n4.  难懂的题目，我加入了代码解析和原理分析。\n\n本篇是这 208 道题中，第一部分“Java 基础”模块的题和答案。\n\n### **Java 基础**\n\n**1\\. JDK 和 JRE 有什么区别？**\n\n*   JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\n\n*   JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n\n**2\\. == 和 equals 的区别是什么？**\n\n**== 解读**\n\n对于基本类型和引用类型 == 的作用效果是不同的，如下所示：\n\n*   基本类型：比较的是值是否相同；\n\n*   引用类型：比较的是引用是否相同；\n\n代码示例：\n\n```\nString x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true\n```\n\n代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。\n\n**equals 解读**\n\nequals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。\n\n首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：\n\n```\nclass Cat {\n    public Cat(String name) {\n        this.name = name;\n    }\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false\n```\n\n输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：\n\n```\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n原来 equals 本质上就是 ==。\n\n那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：\n\n```\nString s1 = new String(\"老王\");\nString s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n```\n\n同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：\n\n```\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。\n\n**总结** ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n**3\\. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？**\n\n不对，两个对象的 hashCode()相同，equals()不一定 true。\n\n代码示例：\n\n```\nString str1 = \"通话\";\nString str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\",  str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n```\n\n执行的结果：\n\nstr1：1179395 | str2：1179395\n\nfalse\n\n代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n\n**4\\. final 在 java 中有什么作用？**\n\n*   final 修饰的类叫最终类，该类不能被继承。\n\n*   final 修饰的方法不能被重写。\n\n*   final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n**5\\. java 中的 Math.round(-1.5) 等于多少？**\n\n等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。\n\n**6\\. String 属于基础的数据类型吗？**\n\nString 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。\n\n**7\\. java 中操作字符串都有哪些类？它们之间有什么区别？**\n\n操作字符串的类有：String、StringBuffer、StringBuilder。\n\nString 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n\n**8\\. String str=\"i\"与 String str=new String(\"i\")一样吗？**\n\n不一样，因为内存的分配方式不一样。String str=\"i\"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(\"i\") 则会被分到堆内存中。\n\n**9\\. 如何将字符串反转？**\n\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n\n示例代码：\n\n```\n// StringBuffer reverse\nStringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n```\n\n**10\\. String 类的常用方法都有那些？**\n\n*   indexOf()：返回指定字符的索引。\n\n*   charAt()：返回指定索引处的字符。\n\n*   replace()：字符串替换。\n\n*   trim()：去除字符串两端空白。\n\n*   split()：分割字符串，返回一个分割后的字符串数组。\n\n*   getBytes()：返回字符串的 byte 类型数组。\n\n*   length()：返回字符串长度。\n\n*   toLowerCase()：将字符串转成小写字母。\n\n*   toUpperCase()：将字符串转成大写字符。\n\n*   substring()：截取字符串。\n\n*   equals()：字符串比较。\n\n**11\\. 抽象类必须要有抽象方法吗？**\n\n不需要，抽象类不一定非要有抽象方法。\n\n示例代码：\n\n```\nabstract class Cat {\n    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n```\n\n上面代码，抽象类并没有抽象方法但完全可以正常运行。\n\n**12\\. 普通类和抽象类有哪些区别？**\n\n*   普通类不能包含抽象方法，抽象类可以包含抽象方法。\n\n*   抽象类不能直接实例化，普通类可以直接实例化。\n\n**13\\. 抽象类能使用 final 修饰吗？**\n\n不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIPT1PAKpMFkqYyedicsJQOufr2NcJQfeXG1tvNJPfMJ7kEZ79hJd1WoDCeSmzbGnqF8ofWsXth5veQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**14\\. 接口和抽象类有什么区别？**\n\n*   实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n\n*   构造函数：抽象类可以有构造函数；接口不能有。\n\n*   main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。\n\n*   实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n\n*   访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n**15\\. java 中 IO 流分为几种？**\n\n按功能来分：输入流（input）、输出流（output）。\n\n按类型来分：字节流和字符流。\n\n字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。\n\n**16\\. BIO、NIO、AIO 有什么区别？**\n\n*   BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\n\n*   NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\n*   AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n**17\\. Files的常用方法都有哪些？**\n\n*   Files.exists()：检测文件路径是否存在。\n*   Files.createFile()：创建文件。\n*   Files.createDirectory()：创建文件夹。\n*   Files.delete()：删除一个文件或目录。\n*   Files.copy()：复制文件。\n*   Files.move()：移动文件。\n*   Files.size()：查看文件个数。\n*   Files.read()：读取文件。\n*   Files.write()：写入文件。",[[1563449603512,["GJX@GJXAIOU",[[-1,75,"![](https://mmbiz.qpic.cn/mmbiz_jpg/QCu849YTaIOib4Wgpnhw92q7t0o8IBe1ltNZ8nSmfR8yrrYoRziccwKhiceiabRzZibfRa2MUKhJRZ0F98IvzRCYaeQ/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n"]],[74,242],[74,74]]],[1563449607507,["GJX@GJXAIOU",[[-1,30,"王磊的博客 [Java团长](javascript:void(0);) _3月12日_\n\n\n来源：王磊的博客"]],[30,84],[30,30]]],[1563449629656,["GJX@GJXAIOU",[[-1,362,"#"]],[363,363],[362,362]]],[1563449633572,["GJX@GJXAIOU",[[-1,0,"#"]],[2,2],[1,1]]],[1563449641555,["GJX@GJXAIOU",[[-1,378,"\\"]],[379,379],[378,378]]],[1563449643866,["GJX@GJXAIOU",[[-1,667,"\\"]],[668,668],[667,667]]],[1563449651741,["GJX@GJXAIOU",[[1,31,"\n"]],[28,28],[29,29]]],[1563449653420,["GJX@GJXAIOU",[[1,29,"@"],[-1,2555," "],[1,2556," "]],[29,29],[30,30]]],[1563449654780,["GJX@GJXAIOU",[[1,30,"通常"]],[30,30],[32,32]]],[1563449655709,["GJX@GJXAIOU",[[-1,30,"通常"]],[32,32],[30,30]]],[1563449657134,["GJX@GJXAIOU",[[1,30,"toc"]],[30,30],[33,33]]],[1563449668553,["GJX@GJXAIOU",[[-1,367,"**"]],[367,369],[367,367]]],[1563449669417,["GJX@GJXAIOU",[[-1,374,"**"]],[376,376],[374,374]]],[1563449673868,["GJX@GJXAIOU",[[1,367,"yi"]],[367,367],[369,369]]],[1563449674810,["GJX@GJXAIOU",[[-1,367,"yi"]],[369,369],[367,367]]],[1563449676174,["GJX@GJXAIOU",[[1,367,"一 "]],[367,367],[368,368]]],[1563449676587,["GJX@GJXAIOU",[[1,368,"、"]],[368,368],[369,369]]],[1563449692666,["GJX@GJXAIOU",[[-1,668,"**"],[-1,692,"**"]],[668,694],[668,690]]],[1563449694305,["GJX@GJXAIOU",[[1,668,"## "]],[668,690],[693,693]]],[1563449695970,["GJX@GJXAIOU",[[1,670,"#"]],[693,693],[694,694]]],[1563449699234,["GJX@GJXAIOU",[[1,379,"### "]],[380,380],[406,406]]],[1563449700385,["GJX@GJXAIOU",[[-1,383,"**"],[-1,404,"**"]],[406,406],[383,402]]],[1563449708137,["GJX@GJXAIOU",[[-1,251,"\n"]],[251,251],[250,250]]],[1563449708882,["GJX@GJXAIOU",[[-1,275,"\n"]],[275,275],[274,274]]],[1563449709577,["GJX@GJXAIOU",[[-1,299,"\n"]],[299,299],[298,298]]],[1563449710299,["GJX@GJXAIOU",[[-1,324,"\n"]],[324,324],[323,323]]],[1563449773677,["GJX@GJXAIOU",[[-1,755,"\n"]],[755,755],[754,754]]],[1563449774413,["GJX@GJXAIOU",[[-1,734,"\n"]],[734,734],[733,733]]],[1563449874890,["GJX@GJXAIOU",[[1,1023,"**"],[1,1041,"**"]],[1023,1041],[1023,1045]]],[1563449898867,["GJX@GJXAIOU",[[1,1165,"**"],[1,1209,"**"]],[1165,1209],[1165,1213]]],[1563450017005,["GJX@GJXAIOU",[[1,1231,"**"],[1,1255,"**"]],[1231,1255],[1231,1259]]],[1563450374306,["GJX@GJXAIOU",[[1,1227,"\n"]],[1225,1225],[1226,1226]]],[1563450384678,["GJX@GJXAIOU",[[1,1226,"byte（字节型）、short（短整型）、int（整型）、long（长整型）、float（单精度浮点型）、double（双精度浮点型）、boolean（布尔型）、char（字符型）\n\n## 对应包装类\n\njava.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character"]],[1226,1226],[1462,1462]]],[1563450393194,["GJX@GJXAIOU",[[-1,1318,"## "]],[1318,1321],[1318,1318]]],[1563450403885,["GJX@GJXAIOU",[[1,1226,"八种 "]],[1226,1226],[1228,1228]]],[1563450407765,["GJX@GJXAIOU",[[1,1228,"基本数据类型："]],[1228,1228],[1235,1235]]],[1563450408058,["GJX@GJXAIOU",[[1,1235,"\n"]],[1235,1235],[1236,1236]]],[1563450410628,["GJX@GJXAIOU",[[1,1226,"- "]],[1226,1226],[1228,1228]]],[1563450413957,["GJX@GJXAIOU",[[1,1331,"- "]],[1331,1331],[1333,1333]]],[1563450416154,["GJX@GJXAIOU",[[-1,1339,"\n"]],[1339,1339],[1338,1338]]],[1563451548025,["GJX@GJXAIOU",[[1,2150,":arrow_down:"]],[2150,2150],[2162,2162]]],[1563451556036,["GJX@GJXAIOU",[[-1,2150,":arrow_down:"]],[2150,2162],[2150,2150]]]],null,"GJX@GJXAIOU"],["634089d8-5507-48c1-95e5-15ac47f645a4",1563458279880,"# Java 最常见的 208 道面试题：第一模块答案\n\n@toc\n\n\n* * *\n\n目前市面上的面试题存在两大问题：第一，题目太旧好久没有更新了，还都停留在 2010 年之前的状态；第二，近几年 JDK 更新和发布都很快，Java 的用法也变了不少，加上 Java 技术栈也加入了很多新的框架，比如 Spring Boot、Spring Cloud 等，但类似的面试题却极少。\n\n相比与这些问题，我的这 208 道面试题具备以下优点：\n\n1.  披沙拣金提炼出每个 Java 模块中最经典的面试题；\n2.  答案准确，每个题目都是我仔细校对过的；\n3.  接近最真实的企业面试，题目实用有效果；\n4.  难懂的题目，我加入了代码解析和原理分析。\n本篇是这 208 道题中，第一部分“Java 基础”模块的题和答案。\n\n## 一、 Java 基础\n\n### 1. JDK 和 JRE 有什么区别？\n\n*   JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\n\n*   JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n\n### 2. == 和 equals 的区别是什么？\n\n**== 解读**\n\n对于基本类型和引用类型 == 的作用效果是不同的，如下所示：\n*   基本类型：比较的是值是否相同；\n*   引用类型：比较的是引用是否相同；\n\n代码示例：\n\n```\nString x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true\n```\n\n代码解读：**因为 x 和 y 指向的是同一个引用**，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。\n\n**equals 解读**\n\nequals 本质上就是 ==，**只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较**。看下面的代码就明白了。\n- 八种基本数据类型：\n byte（字节型）、short（短整型）、int（整型）、long（长整型）、float（单精度浮点型）、double（双精度浮点型）、boolean（布尔型）、char（字符型）\n\n- 对应包装类\njava.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character\n\n首先来看**默认情况下 equals 比较一个有相同值的对象**，代码如下：\n\n```\nclass Cat {\n    public Cat(String name) {\n        this.name = name;\n    }\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false\n```\n\n输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：\n\n```\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n原来 equals 本质上就是 ==。\n\n那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：\n\n```\nString s1 = new String(\"老王\");\nString s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n```\n\n同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：\n\n```\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。\n\n**总结** ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n**3\\. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？**\n\n不对，两个对象的 hashCode()相同，equals()不一定 true。\n\n代码示例：\n\n```\nString str1 = \"通话\";\nString str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\",  str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n```\n\n执行的结果：\n\nstr1：1179395 | str2：1179395\n\nfalse\n\n代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n\n**4\\. final 在 java 中有什么作用？**\n\n*   final 修饰的类叫最终类，该类不能被继承。\n\n*   final 修饰的方法不能被重写。\n\n*   final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n**5\\. java 中的 Math.round(-1.5) 等于多少？**\n\n等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。\n\n**6\\. String 属于基础的数据类型吗？**\n\nString 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。\n\n**7\\. java 中操作字符串都有哪些类？它们之间有什么区别？**\n\n操作字符串的类有：String、StringBuffer、StringBuilder。\n\nString 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n\n**8\\. String str=\"i\"与 String str=new String(\"i\")一样吗？**\n\n不一样，因为内存的分配方式不一样。String str=\"i\"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(\"i\") 则会被分到堆内存中。\n\n**9\\. 如何将字符串反转？**\n\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n\n示例代码：\n\n```\n// StringBuffer reverse\nStringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n```\n\n**10\\. String 类的常用方法都有那些？**\n\n*   indexOf()：返回指定字符的索引。\n\n*   charAt()：返回指定索引处的字符。\n\n*   replace()：字符串替换。\n\n*   trim()：去除字符串两端空白。\n\n*   split()：分割字符串，返回一个分割后的字符串数组。\n\n*   getBytes()：返回字符串的 byte 类型数组。\n\n*   length()：返回字符串长度。\n\n*   toLowerCase()：将字符串转成小写字母。\n\n*   toUpperCase()：将字符串转成大写字符。\n\n*   substring()：截取字符串。\n\n*   equals()：字符串比较。\n\n**11\\. 抽象类必须要有抽象方法吗？**\n\n不需要，抽象类不一定非要有抽象方法。\n\n示例代码：\n\n```\nabstract class Cat {\n    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n```\n\n上面代码，抽象类并没有抽象方法但完全可以正常运行。\n\n**12\\. 普通类和抽象类有哪些区别？**\n\n*   普通类不能包含抽象方法，抽象类可以包含抽象方法。\n\n*   抽象类不能直接实例化，普通类可以直接实例化。\n\n**13\\. 抽象类能使用 final 修饰吗？**\n\n不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIPT1PAKpMFkqYyedicsJQOufr2NcJQfeXG1tvNJPfMJ7kEZ79hJd1WoDCeSmzbGnqF8ofWsXth5veQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**14\\. 接口和抽象类有什么区别？**\n\n*   实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n\n*   构造函数：抽象类可以有构造函数；接口不能有。\n\n*   main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。\n\n*   实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n\n*   访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n**15\\. java 中 IO 流分为几种？**\n\n按功能来分：输入流（input）、输出流（output）。\n\n按类型来分：字节流和字符流。\n\n字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。\n\n**16\\. BIO、NIO、AIO 有什么区别？**\n\n*   BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\n\n*   NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\n*   AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n**17\\. Files的常用方法都有哪些？**\n\n*   Files.exists()：检测文件路径是否存在。\n*   Files.createFile()：创建文件。\n*   Files.createDirectory()：创建文件夹。\n*   Files.delete()：删除一个文件或目录。\n*   Files.copy()：复制文件。\n*   Files.move()：移动文件。\n*   Files.size()：查看文件个数。\n*   Files.read()：读取文件。\n*   Files.write()：写入文件。",[[1563458243611,["GJX@GJXAIOU",[[1,1895,"Object "]],[1895,1895],[1901,1901]]],[1563458245211,["GJX@GJXAIOU",[[1,1901,"类"]],[1901,1901],[1902,1902]]],[1563458245247,["GJX@GJXAIOU",[[1,1901," "]],[1902,1902],[1903,1903]]],[1563458246396,["GJX@GJXAIOU",[[1,1903,"找那个的"]],[1903,1903],[1907,1907]]],[1563458247520,["GJX@GJXAIOU",[[-1,1903,"找那个的"]],[1907,1907],[1903,1903]]],[1563458250924,["GJX@GJXAIOU",[[1,1903,"中的equals"]],[1903,1903],[1911,1911]]],[1563458250955,["GJX@GJXAIOU",[[1,1905," "]],[1911,1911],[1912,1912]]],[1563458254100,["GJX@GJXAIOU",[[1,1912,"()"]],[1912,1912],[1914,1914]]],[1563458257057,["GJX@GJXAIOU",[[1,1962,"\n"]],[1961,1961],[1962,1962]]],[1563458258700,["GJX@GJXAIOU",[[1,1962,"  、"]],[1962,1962],[1965,1965]]],[1563458259171,["GJX@GJXAIOU",[[-1,1964,"、"]],[1965,1965],[1964,1964]]],[1563458278492,["GJX@GJXAIOU",[[1,1964,"  //调用equal的对象的地址和参数对象的"]],[1964,1964],[1987,1987]]],[1563458289962,["GJX@GJXAIOU",[[1,1987,"地址是否相等"]],[1987,1987],[1993,1993]]],[1563458296545,["GJX@GJXAIOU",[[1,2290,"\n"]],[2289,2289],[2290,2290]]],[1563458297466,["GJX@GJXAIOU",[[1,2290,"//"]],[2290,2290],[2292,2292]]],[1563458298359,["GJX@GJXAIOU",[[-1,2290,"//"]],[2292,2292],[2290,2290]]],[1563458300291,["GJX@GJXAIOU",[[1,2290,"    、、"]],[2290,2290],[2296,2296]]],[1563458300880,["GJX@GJXAIOU",[[-1,2294,"、、"]],[2296,2296],[2294,2294]]],[1563458306476,["GJX@GJXAIOU",[[1,2294,"//如果是一个对象"]],[2294,2294],[2303,2303]]],[1563458311426,["GJX@GJXAIOU",[[1,2299,"同"]],[2299,2299],[2300,2300]]],[1563458317176,["GJX@GJXAIOU",[[1,2364,"\n    "]],[2359,2359],[2364,2364]]],[1563458318290,["GJX@GJXAIOU",[[1,2364,"、、"]],[2364,2364],[2366,2366]]],[1563458318903,["GJX@GJXAIOU",[[-1,2364,"、、"]],[2366,2366],[2364,2364]]],[1563458323604,["GJX@GJXAIOU",[[1,2364,"//如果传递尽量"]],[2364,2364],[2372,2372]]],[1563458324799,["GJX@GJXAIOU",[[-1,2370,"尽量"]],[2372,2372],[2370,2370]]],[1563458331718,["GJX@GJXAIOU",[[1,2370,"进来的参数是S填入哪个"]],[2370,2370],[2381,2381]]],[1563458333023,["GJX@GJXAIOU",[[-1,2376,"S填入哪个"]],[2381,2381],[2376,2376]]],[1563458337861,["GJX@GJXAIOU",[[1,2376,"String类的"]],[2376,2376],[2384,2384]]],[1563458339300,["GJX@GJXAIOU",[[1,2384,"实例"]],[2384,2384],[2386,2386]]],[1563458343649,["GJX@GJXAIOU",[[1,2503," "]],[2503,2503],[2504,2504]]],[1563458345040,["GJX@GJXAIOU",[[-1,2503," "]],[2504,2504],[2503,2503]]],[1563458353346,["GJX@GJXAIOU",[[1,2503,"//zi"]],[2503,2503],[2507,2507]]],[1563458354071,["GJX@GJXAIOU",[[-1,2505,"zi"]],[2507,2507],[2505,2505]]],[1563458362654,["GJX@GJXAIOU",[[1,2505,"字符串长度"]],[2505,2505],[2510,2510]]],[1563458367523,["GJX@GJXAIOU",[[1,2557," 、、"]],[2557,2557],[2560,2560]]],[1563458368112,["GJX@GJXAIOU",[[-1,2558,"、、"]],[2560,2560],[2558,2558]]],[1563458368874,["GJX@GJXAIOU",[[1,2558,"？、"]],[2558,2558],[2560,2560]]],[1563458369848,["GJX@GJXAIOU",[[-1,2558,"？、"]],[2560,2560],[2558,2558]]],[1563458370523,["GJX@GJXAIOU",[[1,2558,"/、"]],[2558,2558],[2560,2560]]],[1563458371144,["GJX@GJXAIOU",[[-1,2559,"、"]],[2560,2560],[2559,2559]]],[1563458371635,["GJX@GJXAIOU",[[1,2559,"、"]],[2559,2559],[2560,2560]]],[1563458372231,["GJX@GJXAIOU",[[-1,2559,"、"]],[2560,2560],[2559,2559]]],[1563458380131,["GJX@GJXAIOU",[[1,2559,"/如果字符串长度相等"]],[2559,2559],[2569,2569]]],[1563458387388,["GJX@GJXAIOU",[[1,2600," //取码"]],[2600,2600],[2605,2605]]],[1563458388864,["GJX@GJXAIOU",[[-1,2604,"码"]],[2605,2605],[2604,2604]]],[1563458395068,["GJX@GJXAIOU",[[1,2604,"每一个位置的字符"]],[2604,2604],[2612,2612]]],[1563458401011,["GJX@GJXAIOU",[[1,2711," 、、"]],[2711,2711],[2714,2714]]],[1563458401600,["GJX@GJXAIOU",[[-1,2712,"、、"]],[2714,2714],[2712,2712]]],[1563458414619,["GJX@GJXAIOU",[[1,2712,"//对于每一个位置逐一比较"]],[2712,2712],[2725,2725]]]],null,"GJX@GJXAIOU"],["600ba9ec-cded-45ac-8df4-afd728f8c437",1563516627276,"# Java 最常见的 208 道面试题：第一模块答案\n\n@toc\n\n\n* * *\n\n目前市面上的面试题存在两大问题：第一，题目太旧好久没有更新了，还都停留在 2010 年之前的状态；第二，近几年 JDK 更新和发布都很快，Java 的用法也变了不少，加上 Java 技术栈也加入了很多新的框架，比如 Spring Boot、Spring Cloud 等，但类似的面试题却极少。\n\n相比与这些问题，我的这 208 道面试题具备以下优点：\n\n1.  披沙拣金提炼出每个 Java 模块中最经典的面试题；\n2.  答案准确，每个题目都是我仔细校对过的；\n3.  接近最真实的企业面试，题目实用有效果；\n4.  难懂的题目，我加入了代码解析和原理分析。\n本篇是这 208 道题中，第一部分“Java 基础”模块的题和答案。\n\n## 一、 Java 基础\n\n### 1. JDK 和 JRE 有什么区别？\n\n*   JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\n\n*   JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n\n### 2. == 和 equals 的区别是什么？\n\n**== 解读**\n\n对于基本类型和引用类型 == 的作用效果是不同的，如下所示：\n*   基本类型：比较的是值是否相同；\n*   引用类型：比较的是引用是否相同；\n\n代码示例：\n\n```\nString x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true\n```\n\n代码解读：**因为 x 和 y 指向的是同一个引用**，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。\n\n**equals 解读**\n\nequals 本质上就是 ==，**只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较**。看下面的代码就明白了。\n- 八种基本数据类型：\n byte（字节型）、short（短整型）、int（整型）、long（长整型）、float（单精度浮点型）、double（双精度浮点型）、boolean（布尔型）、char（字符型）\n\n- 对应包装类\njava.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character\n\n首先来看**默认情况下 equals 比较一个有相同值的对象**，代码如下：\n\n```\nclass Cat {\n    public Cat(String name) {\n        this.name = name;\n    }\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false\n```\n\n输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，Object 类中的 equals() 源码如下：\n\n```\npublic boolean equals(Object obj) {\n    //调用equal的对象的地址和参数对象的地址是否相等\n    return (this == obj);\n}\n```\n\n原来 equals 本质上就是 ==。\n\n那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：\n\n```\nString s1 = new String(\"老王\");\nString s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n```\n\n同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：\n\n```\npublic boolean equals(Object anObject) {\n    //如果是同一个对象\n    if (this == anObject) {\n        return true;\n    }\n    //如果传递进来的参数是String类的实例\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;//字符串长度\n        if (n == anotherString.value.length) { //如果字符串长度相等\n            char v1[] = value; //取每一个位置的字符\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) { //对于每一个位置逐一比较\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。\n\n**总结** ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n**3\\. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？**\n\n不对，两个对象的 hashCode()相同，equals()不一定 true。\n\n代码示例：\n\n```\nString str1 = \"通话\";\nString str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\",  str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n```\n\n执行的结果：\n\nstr1：1179395 | str2：1179395\n\nfalse\n\n代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n\n**4\\. final 在 java 中有什么作用？**\n\n*   final 修饰的类叫最终类，该类不能被继承。\n\n*   final 修饰的方法不能被重写。\n\n*   final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n**5\\. java 中的 Math.round(-1.5) 等于多少？**\n\n等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。\n\n**6\\. String 属于基础的数据类型吗？**\n\nString 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。\n\n**7\\. java 中操作字符串都有哪些类？它们之间有什么区别？**\n\n操作字符串的类有：String、StringBuffer、StringBuilder。\n\nString 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n\n**8\\. String str=\"i\"与 String str=new String(\"i\")一样吗？**\n\n不一样，因为内存的分配方式不一样。String str=\"i\"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(\"i\") 则会被分到堆内存中。\n\n**9\\. 如何将字符串反转？**\n\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n\n示例代码：\n\n```\n// StringBuffer reverse\nStringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n```\n\n**10\\. String 类的常用方法都有那些？**\n\n*   indexOf()：返回指定字符的索引。\n\n*   charAt()：返回指定索引处的字符。\n\n*   replace()：字符串替换。\n\n*   trim()：去除字符串两端空白。\n\n*   split()：分割字符串，返回一个分割后的字符串数组。\n\n*   getBytes()：返回字符串的 byte 类型数组。\n\n*   length()：返回字符串长度。\n\n*   toLowerCase()：将字符串转成小写字母。\n\n*   toUpperCase()：将字符串转成大写字符。\n\n*   substring()：截取字符串。\n\n*   equals()：字符串比较。\n\n**11\\. 抽象类必须要有抽象方法吗？**\n\n不需要，抽象类不一定非要有抽象方法。\n\n示例代码：\n\n```\nabstract class Cat {\n    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n```\n\n上面代码，抽象类并没有抽象方法但完全可以正常运行。\n\n**12\\. 普通类和抽象类有哪些区别？**\n\n*   普通类不能包含抽象方法，抽象类可以包含抽象方法。\n\n*   抽象类不能直接实例化，普通类可以直接实例化。\n\n**13\\. 抽象类能使用 final 修饰吗？**\n\n不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIPT1PAKpMFkqYyedicsJQOufr2NcJQfeXG1tvNJPfMJ7kEZ79hJd1WoDCeSmzbGnqF8ofWsXth5veQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**14\\. 接口和抽象类有什么区别？**\n\n*   实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n\n*   构造函数：抽象类可以有构造函数；接口不能有。\n\n*   main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。\n\n*   实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n\n*   访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n**15\\. java 中 IO 流分为几种？**\n\n按功能来分：输入流（input）、输出流（output）。\n\n按类型来分：字节流和字符流。\n\n字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。\n\n**16\\. BIO、NIO、AIO 有什么区别？**\n\n*   BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\n\n*   NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\n*   AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n**17\\. Files的常用方法都有哪些？**\n\n*   Files.exists()：检测文件路径是否存在。\n*   Files.createFile()：创建文件。\n*   Files.createDirectory()：创建文件夹。\n*   Files.delete()：删除一个文件或目录。\n*   Files.copy()：复制文件。\n*   Files.move()：移动文件。\n*   Files.size()：查看文件个数。\n*   Files.read()：读取文件。\n*   Files.write()：写入文件。",[[1563516581519,["GJX@GJXAIOU",[[-1,3082,"\\"]],[3083,3083],[3082,3082]]],[1563516593921,["GJX@GJXAIOU",[[-1,3079,"**"],[-1,3126,"**"]],[3086,3086],[3079,3124]]],[1563516595941,["GJX@GJXAIOU",[[1,3079,"### "]],[3079,3124],[3128,3128]]],[1563516745704,["GJX@GJXAIOU",[[1,3460,"（）"]],[3460,3460],[3462,3462]]],[1563516748556,["GJX@GJXAIOU",[[1,3461,"哈希表"]],[3461,3461],[3464,3464]]],[1563516752163,["GJX@GJXAIOU",[[-1,3515,"**"],[-1,3541,"**"]],[3520,3520],[3515,3539]]],[1563516754539,["GJX@GJXAIOU",[[-1,3516,"\\"]],[3517,3517],[3516,3516]]],[1563516755659,["GJX@GJXAIOU",[[1,3515,"### "]],[3516,3516],[3542,3542]]],[1563516787759,["GJX@GJXAIOU",[[1,3363,"···"]],[3363,3363],[3366,3366]]],[1563516789019,["GJX@GJXAIOU",[[-1,3363,"···"]],[3366,3366],[3363,3363]]],[1563516790381,["GJX@GJXAIOU",[[1,3363,"```"]],[3363,3363],[3366,3366]]],[1563516791796,["GJX@GJXAIOU",[[1,3402,"```"]],[3402,3402],[3405,3405]]],[1563516793748,["GJX@GJXAIOU",[[-1,3395,"\n"]],[3395,3395],[3394,3394]]],[1563518776413,["GJX@GJXAIOU",[[-1,3577,"\n"]],[3577,3577],[3576,3576]]],[1563518782429,["GJX@GJXAIOU",[[-1,3599,"\n"]],[3599,3599],[3598,3598]]],[1563518785645,["GJX@GJXAIOU",[[-1,3644,"\\"]],[3645,3645],[3644,3644]]],[1563518787175,["GJX@GJXAIOU",[[-1,3641,"**"],[-1,3676,"**"]],[3644,3644],[3641,3674]]],[1563518789597,["GJX@GJXAIOU",[[1,3641,"### "]],[3641,3674],[3678,3678]]],[1563518803038,["GJX@GJXAIOU",[[1,663,"---"]],[663,663],[666,666]]],[1563518805574,["GJX@GJXAIOU",[[1,667,"\n"]],[666,666],[667,667]]],[1563518807030,["GJX@GJXAIOU",[[1,663,"\n"]],[663,663],[664,664]]],[1563518812037,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1563518814055,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1563518814222,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1563518816902,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1563518818237,["GJX@GJXAIOU",[[1,4,"\n"]],[3,3],[4,4]]],[1563518818382,["GJX@GJXAIOU",[[1,5,"\n"]],[4,4],[5,5]]],[1563518819127,["GJX@GJXAIOU",[[1,5,"---"]],[5,5],[8,8]]],[1563518824660,["GJX@GJXAIOU",[[-1,0,"---\n\n---"]],[0,8],[0,0]]],[1563518826516,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1563518828281,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1563518828751,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1563518829070,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1563518831252,["GJX@GJXAIOU",[[-1,0,"---"]],[0,3],[0,0]]],[1563518833280,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1563518833736,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1563518834018,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1563518835589,["GJX@GJXAIOU",[[-1,0,"---"]],[0,3],[0,0]]],[1563518836093,["GJX@GJXAIOU",[[1,2,"\n"]],[0,0],[1,1]]],[1563518838017,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1563518838335,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1563518838583,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1563518840365,["GJX@GJXAIOU",[[-1,0,"---"]],[3,3],[0,0]]],[1563518841727,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1563518841989,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1563518842246,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1563518844311,["GJX@GJXAIOU",[[1,6,"\n"]],[3,3],[4,4]]],[1563518844613,["GJX@GJXAIOU",[[1,7,"\n"]],[4,4],[5,5]]],[1563518846248,["GJX@GJXAIOU",[[1,5,"---"]],[5,5],[8,8]]],[1563518852695,["GJX@GJXAIOU",[[1,4,"style: summer"]],[4,4],[17,17]]],[1563518856301,["GJX@GJXAIOU",[[-1,23,"\n"]],[22,22],[21,21]]],[1563518856845,["GJX@GJXAIOU",[[-1,20,"-"]],[21,21],[20,20]]],[1563518858990,["GJX@GJXAIOU",[[1,20,"-"]],[20,20],[21,21]]],[1563518876446,["GJX@GJXAIOU",[[1,3107,"\n"]],[3106,3106],[3107,3107]]],[1563518877544,["GJX@GJXAIOU",[[1,3107,"--- "]],[3107,3107],[3111,3111]]],[1563518878590,["GJX@GJXAIOU",[[1,3112,"\n"]],[3111,3111],[3112,3112]]],[1563518887015,["GJX@GJXAIOU",[[1,3558,"**"],[1,3581,"**"]],[3558,3581],[3558,3585]]],[1563518892430,["GJX@GJXAIOU",[[1,3117,"**"],[1,3162,"**"]],[3117,3162],[3117,3166]]],[1563518901412,["GJX@GJXAIOU",[[1,699,"**"],[1,718,"**"]],[699,718],[699,722]]],[1563518906741,["GJX@GJXAIOU",[[1,402,"**"],[1,421,"**"]],[402,421],[402,425]]],[1563518921500,["GJX@GJXAIOU",[[1,3698,"**"],[1,3728,"**"]],[3698,3728],[3698,3732]]],[1563518926885,["GJX@GJXAIOU",[[-1,3698,"**"]],[3698,3700],[3698,3698]]],[1563518928693,["GJX@GJXAIOU",[[1,3695,"**"]],[3695,3695],[3697,3697]]],[1563518931581,["GJX@GJXAIOU",[[1,3691,"\n"]],[3690,3690],[3691,3691]]],[1563518932344,["GJX@GJXAIOU",[[1,3691,"---"]],[3691,3691],[3694,3694]]],[1563518933124,["GJX@GJXAIOU",[[1,3695,"\n"]],[3694,3694],[3695,3695]]],[1563518971349,["GJX@GJXAIOU",[[1,3763,"**"],[1,3767,"**"]],[3763,3767],[3763,3771]]],[1563518975925,["GJX@GJXAIOU",[[1,3800,"\n"]],[3799,3799],[3800,3800]]],[1563518976721,["GJX@GJXAIOU",[[1,3800,"---"]],[3800,3800],[3803,3803]]],[1563518977310,["GJX@GJXAIOU",[[1,3804,"\n"]],[3803,3803],[3804,3804]]],[1563518979990,["GJX@GJXAIOU",[[1,3805,"### "]],[3805,3805],[3835,3835]]],[1563518987645,["GJX@GJXAIOU",[[-1,3812,"\\"]],[3813,3813],[3812,3812]]],[1563518991607,["GJX@GJXAIOU",[[-1,3926,"\\"]],[3927,3927],[3926,3926]]],[1563518992484,["GJX@GJXAIOU",[[1,3923,"### "]],[3926,3926],[3961,3961]]],[1563518994047,["GJX@GJXAIOU",[[1,3923,"\n"]],[3922,3922],[3923,3923]]],[1563518994742,["GJX@GJXAIOU",[[1,3923,"---"]],[3923,3923],[3926,3926]]],[1563518995862,["GJX@GJXAIOU",[[1,3927,"\n"]],[3926,3926],[3927,3927]]],[1563519015798,["GJX@GJXAIOU",[[1,4362,"### "]],[4363,4363],[4420,4420]]],[1563519017278,["GJX@GJXAIOU",[[1,4517,"### "]],[4518,4518],[4538,4538]]],[1563519020081,["GJX@GJXAIOU",[[1,4361,"---"]],[4361,4361],[4364,4364]]],[1563519020982,["GJX@GJXAIOU",[[1,4365,"\n"]],[4364,4364],[4365,4365]]],[1563519022461,["GJX@GJXAIOU",[[1,4361,"\n"]],[4361,4361],[4362,4362]]],[1563519026118,["GJX@GJXAIOU",[[1,4522,"\n"]],[4521,4521],[4522,4522]]],[1563519026911,["GJX@GJXAIOU",[[1,4522,"---"]],[4522,4522],[4525,4525]]],[1563519027613,["GJX@GJXAIOU",[[1,4526,"\n"]],[4525,4525],[4526,4526]]],[1563519033757,["GJX@GJXAIOU",[[-1,4374,"\\"]],[4375,4375],[4374,4374]]],[1563519035725,["GJX@GJXAIOU",[[-1,4533,"\\"]],[4534,4534],[4533,4533]]],[1563519046605,["GJX@GJXAIOU",[[1,4475,"**"],[1,4478,"**"]],[4475,4478],[4475,4482]]],[1563519050101,["GJX@GJXAIOU",[[1,4518,"**"],[1,4522,"**"]],[4518,4522],[4518,4526]]],[1563519065069,["GJX@GJXAIOU",[[1,4946,"### "]],[4946,4946],[4977,4977]]],[1563519067509,["GJX@GJXAIOU",[[-1,4954,"\\"]],[4955,4955],[4954,4954]]],[1563519069934,["GJX@GJXAIOU",[[-1,5003,"\n"]],[5003,5003],[5002,5002]]],[1563519070735,["GJX@GJXAIOU",[[-1,5028,"\n"]],[5028,5028],[5027,5027]]],[1563519071349,["GJX@GJXAIOU",[[-1,5049,"\n"]],[5049,5049],[5048,5048]]],[1563519072064,["GJX@GJXAIOU",[[-1,5071,"\n"]],[5071,5071],[5070,5070]]],[1563519072861,["GJX@GJXAIOU",[[-1,5104,"\n"]],[5104,5104],[5103,5103]]],[1563519073516,["GJX@GJXAIOU",[[-1,5137,"\n"]],[5137,5137],[5136,5136]]],[1563519074790,["GJX@GJXAIOU",[[-1,5159,"\n"]],[5159,5159],[5158,5158]]],[1563519075541,["GJX@GJXAIOU",[[-1,5189,"\n"]],[5189,5189],[5188,5188]]],[1563519076188,["GJX@GJXAIOU",[[-1,5219,"\n"]],[5219,5219],[5218,5218]]],[1563519076908,["GJX@GJXAIOU",[[-1,5242,"\n"]],[5242,5242],[5241,5241]]],[1563519079462,["GJX@GJXAIOU",[[-1,4977,"\n"]],[4977,4977],[4976,4976]]],[1563519081038,["GJX@GJXAIOU",[[1,4946,"\n"]],[4945,4945],[4946,4946]]],[1563519082689,["GJX@GJXAIOU",[[1,4946,"---"]],[4946,4946],[4949,4949]]],[1563519083375,["GJX@GJXAIOU",[[1,4950,"\n"]],[4949,4949],[4950,4950]]],[1563519086117,["GJX@GJXAIOU",[[-1,5290,"\n"]],[5290,5290],[5289,5289]]],[1563519088845,["GJX@GJXAIOU",[[1,5267,"### "]],[5267,5267],[5293,5293]]],[1563519091509,["GJX@GJXAIOU",[[-1,5320,"\n"]],[5320,5320],[5319,5319]]],[1563519093687,["GJX@GJXAIOU",[[-1,5476,"\n"]],[5476,5476],[5475,5475]]],[1563519094278,["GJX@GJXAIOU",[[-1,5505,"\n"]],[5505,5505],[5504,5504]]],[1563519097062,["GJX@GJXAIOU",[[1,5453,"### "]],[5453,5453],[5479,5479]]],[1563519099782,["GJX@GJXAIOU",[[1,5537,"### "]],[5537,5537],[5567,5567]]],[1563519102038,["GJX@GJXAIOU",[[1,5453,"\n"]],[5452,5452],[5453,5453]]],[1563519102768,["GJX@GJXAIOU",[[1,5453,"---"]],[5453,5453],[5456,5456]]],[1563519103573,["GJX@GJXAIOU",[[1,5457,"\n"]],[5456,5456],[5457,5457]]],[1563519105806,["GJX@GJXAIOU",[[1,5542,"\n"]],[5541,5541],[5542,5542]]],[1563519106615,["GJX@GJXAIOU",[[1,5542,"---"]],[5542,5542],[5545,5545]]],[1563519107358,["GJX@GJXAIOU",[[1,5546,"\n"]],[5545,5545],[5546,5546]]],[1563519111229,["GJX@GJXAIOU",[[-1,5555,"\\"]],[5556,5556],[5555,5555]]],[1563519113407,["GJX@GJXAIOU",[[-1,5466,"\\"]],[5467,5467],[5466,5466]]],[1563519120500,["GJX@GJXAIOU",[[-1,5275,"\\"]],[5276,5276],[5275,5275]]],[1563519174983,["GJX@GJXAIOU",[[1,4055,"**"],[1,4072,"**"]],[4055,4072],[4055,4076]]],[1563519233118,["GJX@GJXAIOU",[[1,4780,"\n"]],[4779,4779],[4780,4780]]]],null,"GJX@GJXAIOU"],["f9473ff5-e437-4592-8e46-da182e0a6a5e",1564814584416,"---\nstyle: summer\n---\n\n# Java 最常见的 208 道面试题：第一模块答案\n\n@toc\n\n\n* * *\n\n目前市面上的面试题存在两大问题：第一，题目太旧好久没有更新了，还都停留在 2010 年之前的状态；第二，近几年 JDK 更新和发布都很快，Java 的用法也变了不少，加上 Java 技术栈也加入了很多新的框架，比如 Spring Boot、Spring Cloud 等，但类似的面试题却极少。\n\n相比与这些问题，我的这 208 道面试题具备以下优点：\n\n1.  披沙拣金提炼出每个 Java 模块中最经典的面试题；\n2.  答案准确，每个题目都是我仔细校对过的；\n3.  接近最真实的企业面试，题目实用有效果；\n4.  难懂的题目，我加入了代码解析和原理分析。\n本篇是这 208 道题中，第一部分“Java 基础”模块的题和答案。\n\n## 一、 Java 基础\n\n### **1. JDK 和 JRE 有什么区别？**\n\n*   JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\n\n*   JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n\n---\n\n### 2. **== 和 equals 的区别是什么？**\n\n**== 解读**\n\n对于基本类型和引用类型 == 的作用效果是不同的，如下所示：\n*   基本类型：比较的是值是否相同；\n*   引用类型：比较的是引用是否相同；\n\n代码示例：\n\n```\nString x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true\n```\n\n代码解读：**因为 x 和 y 指向的是同一个引用**，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。\n\n**equals 解读**\n\nequals 本质上就是 ==，**只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较**。看下面的代码就明白了。\n- 八种基本数据类型：\n byte（字节型）、short（短整型）、int（整型）、long（长整型）、float（单精度浮点型）、double（双精度浮点型）、boolean（布尔型）、char（字符型）\n\n- 对应包装类\njava.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character\n\n首先来看**默认情况下 equals 比较一个有相同值的对象**，代码如下：\n\n```\nclass Cat {\n    public Cat(String name) {\n        this.name = name;\n    }\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false\n```\n\n输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，Object 类中的 equals() 源码如下：\n\n```\npublic boolean equals(Object obj) {\n    //调用equal的对象的地址和参数对象的地址是否相等\n    return (this == obj);\n}\n```\n\n原来 equals 本质上就是 ==。\n\n那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：\n\n```\nString s1 = new String(\"老王\");\nString s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n```\n\n同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：\n\n```\npublic boolean equals(Object anObject) {\n    //如果是同一个对象\n    if (this == anObject) {\n        return true;\n    }\n    //如果传递进来的参数是String类的实例\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;//字符串长度\n        if (n == anotherString.value.length) { //如果字符串长度相等\n            char v1[] = value; //取每一个位置的字符\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) { //对于每一个位置逐一比较\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。\n\n**总结** ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n--- \n\n### **3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？**\n\n不对，两个对象的 hashCode()相同，equals()不一定 true。\n\n代码示例：\n\n```\nString str1 = \"通话\";\nString str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\",  str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n```\n\n执行的结果：\n```\nstr1：1179395 | str2：1179395\nfalse\n```\n代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表（哈希表）中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n\n### **4. final 在 java 中有什么作用？**\n\n*   final 修饰的类叫最终类，该类不能被继承。\n*   final 修饰的方法不能被重写。\n*   final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n---\n\n### **5. java 中的 Math.round(-1.5) 等于多少？**\n\n等于 -1，因为在数轴上取值时，中间值（0.5）**向右取整**，所以正 0.5 是往上取整，负 0.5 是直接舍弃。\n\n---\n\n### **6. String 属于基础的数据类型吗？**\n\nString 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。\n\n---\n\n### **7. java 中操作字符串都有哪些类？它们之间有什么区别？**\n\n操作字符串的类有：String、StringBuffer、StringBuilder。\n\nString 和 StringBuffer、StringBuilder 的区别在于 **String 声明的是不可变的对象**，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n\n---\n\n### **8. String str=\"i\"与 String str=new String(\"i\")一样吗？**\n\n不一样，因为内存的分配方式不一样。String str=\"i\"的方式，java 虚拟机会将其分配到**常量池**中；而 String str=new String(\"i\") 则会被分到**堆内存中**。\n\n---\n\n### **9. 如何将字符串反转？**\n\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n\n示例代码：\n\n```\n// StringBuffer reverse\nStringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n```\n\n---\n\n### **10. String 类的常用方法都有那些？**\n*   indexOf()：返回指定字符的索引。\n*   charAt()：返回指定索引处的字符。\n*   replace()：字符串替换。\n*   trim()：去除字符串两端空白。\n*   split()：分割字符串，返回一个分割后的字符串数组。\n*   getBytes()：返回字符串的 byte 类型数组。\n*   length()：返回字符串长度。\n*   toLowerCase()：将字符串转成小写字母。\n*   toUpperCase()：将字符串转成大写字符。\n*   substring()：截取字符串。\n*   equals()：字符串比较。\n\n### **11. 抽象类必须要有抽象方法吗？**\n不需要，抽象类不一定非要有抽象方法。\n\n示例代码：\n```\nabstract class Cat {\n    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n```\n\n上面代码，抽象类并没有抽象方法但完全可以正常运行。\n\n---\n\n### **12. 普通类和抽象类有哪些区别？**\n*   普通类不能包含抽象方法，抽象类可以包含抽象方法。\n*   抽象类不能直接实例化，普通类可以直接实例化。\n\n---\n\n### **13. 抽象类能使用 final 修饰吗？**\n\n不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIPT1PAKpMFkqYyedicsJQOufr2NcJQfeXG1tvNJPfMJ7kEZ79hJd1WoDCeSmzbGnqF8ofWsXth5veQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**14\\. 接口和抽象类有什么区别？**\n\n*   实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n\n*   构造函数：抽象类可以有构造函数；接口不能有。\n\n*   main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。\n\n*   实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n\n*   访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n**15\\. java 中 IO 流分为几种？**\n\n按功能来分：输入流（input）、输出流（output）。\n\n按类型来分：字节流和字符流。\n\n字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。\n\n**16\\. BIO、NIO、AIO 有什么区别？**\n\n*   BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\n\n*   NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\n*   AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n**17\\. Files的常用方法都有哪些？**\n\n*   Files.exists()：检测文件路径是否存在。\n*   Files.createFile()：创建文件。\n*   Files.createDirectory()：创建文件夹。\n*   Files.delete()：删除一个文件或目录。\n*   Files.copy()：复制文件。\n*   Files.move()：移动文件。\n*   Files.size()：查看文件个数。\n*   Files.read()：读取文件。\n*   Files.write()：写入文件。",[[1564814532135,["GJX@GJXAIOU",[[1,18,"\n"]],[17,17],[18,18]]],[1564814539129,["GJX@GJXAIOU",[[1,18,"tags "]],[18,18],[23,23]]],[1564814539735,["GJX@GJXAIOU",[[-1,22," "]],[23,23],[22,22]]],[1564814540456,["GJX@GJXAIOU",[[1,22,"： "]],[22,22],[24,24]]],[1564814541200,["GJX@GJXAIOU",[[-1,22,"： "]],[24,24],[22,22]]],[1564814542130,["GJX@GJXAIOU",[[1,22,"："]],[22,22],[23,23]]],[1564814543009,["GJX@GJXAIOU",[[-1,22,"："]],[23,23],[22,22]]],[1564814545441,["GJX@GJXAIOU",[[1,22,": []"]],[22,22],[26,26]]],[1564814547713,["GJX@GJXAIOU",[[1,25,"m"]],[25,25],[26,26]]],[1564814548207,["GJX@GJXAIOU",[[-1,25,"m"]],[26,26],[25,25]]],[1564814549717,["GJX@GJXAIOU",[[1,25,"面试"]],[25,25],[27,27]]],[1564814580256,["GJX@GJXAIOU",[[-1,77,"目前市面上的面试题存在两大问题：第一，题目太旧好久没有更新了，还都停留在 2010 年之前的状态；第二，近几年 JDK 更新和发布都很快，Java 的用法也变了不少，加上 Java 技术栈也加入了很多新的框架，比如 Spring Boot、Spring Cloud 等，但类似的面试题却极少。\n\n相比与这些问题，我的这 208 道面试题具备以下优点：\n\n1.  披沙拣金提炼出每个 Java 模块中最经典的面试题；\n2.  答案准确，每个题目都是我仔细校对过的；\n3.  接近最真实的企业面试，题目实用有效果；\n4.  难懂的题目，我加入了代码解析和原理分析。\n本篇是这 208 道题中，第一部分“Java 基础”模块的题和答案。"]],[77,392],[77,77]]],[1564814580774,["GJX@GJXAIOU",[[-1,78,"\n"]],[77,77],[76,76]]],[1564814581550,["GJX@GJXAIOU",[[-1,77,"\n"]],[76,76],[75,75]]],[1564814587735,["GJX@GJXAIOU",[[-1,96,"**"]],[98,98],[96,96]]],[1564814589277,["GJX@GJXAIOU",[[-1,115,"**"]],[117,117],[115,115]]],[1564814605951,["GJX@GJXAIOU",[[-1,393,"**"]],[395,395],[393,393]]],[1564814608008,["GJX@GJXAIOU",[[-1,412,"**"]],[414,414],[412,412]]],[1564814609863,["GJX@GJXAIOU",[[-1,424,"\n"]],[424,424],[423,423]]],[1564814610832,["GJX@GJXAIOU",[[-1,413,"\n"]],[413,413],[412,412]]],[1564814613585,["GJX@GJXAIOU",[[1,413,"\n"]],[412,412],[413,413]]],[1564814616680,["GJX@GJXAIOU",[[-1,503,"\n"]],[503,503],[502,502]]],[1564814618305,["GJX@GJXAIOU",[[-1,496,"\n"]],[496,496],[495,495]]],[1564814620455,["GJX@GJXAIOU",[[1,496,"* \n"]],[495,495],[498,498]]],[1564814621799,["GJX@GJXAIOU",[[-1,496,"* "]],[498,498],[496,496]]],[1564814632704,["GJX@GJXAIOU",[[1,414,"- "]],[414,414],[416,416]]],[1564814636494,["GJX@GJXAIOU",[[1,457,"  "],[1,477,"  "]],[457,497],[457,501]]],[1564814643561,["GJX@GJXAIOU",[[1,860,"- "]],[860,860],[862,862]]],[1564814645912,["GJX@GJXAIOU",[[1,954,"  "]],[955,955],[957,957]]],[1564814646703,["GJX@GJXAIOU",[[1,1061,"  "]],[1063,1063],[1065,1065]]],[1564814651175,["GJX@GJXAIOU",[[-1,876,"\n"]],[876,876],[875,875]]],[1564814657735,["GJX@GJXAIOU",[[-1,1245,"\n"]],[1245,1245],[1244,1244]]],[1564814662136,["GJX@GJXAIOU",[[-1,1578,"\n"]],[1578,1578],[1577,1577]]],[1564814664353,["GJX@GJXAIOU",[[-1,1650,"\n"]],[1650,1650],[1649,1649]]],[1564814681202,["GJX@GJXAIOU",[[-1,2851,"也"],[1,2852,"不"],[-1,2854,"为"]],[2851,2851],[2854,2854]]],[1564814686134,["GJX@GJXAIOU",[[-1,2859,"，对吗？**"]],[2859,2865],[2859,2859]]],[1564814688728,["GJX@GJXAIOU",[[-1,2817,"**"]],[2819,2819],[2817,2817]]],[1564814693443,["GJX@GJXAIOU",[[1,2852,"是"]],[2852,2852],[2853,2853]]],[1564814694831,["GJX@GJXAIOU",[[-1,2853," "]],[2854,2854],[2853,2853]]],[1564814699455,["GJX@GJXAIOU",[[-1,2859,"不对，"]],[2859,2862],[2859,2859]]],[1564814701239,["GJX@GJXAIOU",[[-1,2896,"\n"]],[2896,2896],[2895,2895]]],[1564814702862,["GJX@GJXAIOU",[[-1,2902,"\n"]],[2902,2902],[2901,2901]]],[1564814746060,["GJX@GJXAIOU",[[1,5521,"---"]],[5521,5521],[5524,5524]]],[1564814748471,["GJX@GJXAIOU",[[1,5521,"\n"]],[5521,5521],[5522,5522]]],[1564814752817,["GJX@GJXAIOU",[[1,5767,"---"]],[5767,5767],[5770,5770]]],[1564814756057,["GJX@GJXAIOU",[[1,5905,"---"]],[5905,5905],[5908,5908]]],[1564814758463,["GJX@GJXAIOU",[[1,5905,"\n"]],[5905,5905],[5906,5906]]],[1564814761980,["GJX@GJXAIOU",[[1,6149,"---"]],[6149,6149],[6152,6152]]],[1564814766294,["GJX@GJXAIOU",[[-1,6175,"**"]],[6177,6177],[6175,6175]]],[1564814768799,["GJX@GJXAIOU",[[-1,6153,"**"]],[6153,6155],[6153,6153]]],[1564814770367,["GJX@GJXAIOU",[[1,6153,"### "]],[6153,6153],[6177,6177]]],[1564816051294,["GJX@GJXAIOU",[[1,4950,"\n"]],[4949,4949],[4950,4950]]],[1564816052026,["GJX@GJXAIOU",[[1,4950,"---"]],[4950,4950],[4953,4953]]],[1564816055198,["GJX@GJXAIOU",[[-1,4638,"**"],[-1,4662,"**"]],[4642,4642],[4638,4660]]],[1564816056991,["GJX@GJXAIOU",[[-1,4954,"**"],[-1,4973,"**"]],[4961,4961],[4954,4971]]],[1564816060143,["GJX@GJXAIOU",[[-1,4220,"**"],[-1,4234,"**"]],[4227,4227],[4220,4232]]],[1564816061926,["GJX@GJXAIOU",[[-1,4053,"**"],[-1,4104,"**"]],[4072,4072],[4053,4102]]],[1564816063999,["GJX@GJXAIOU",[[-1,3610,"**"],[-1,3642,"**"]],[3622,3622],[3610,3640]]],[1564816065839,["GJX@GJXAIOU",[[-1,3487,"**"],[-1,3510,"**"]],[3498,3498],[3487,3508]]],[1564816067238,["GJX@GJXAIOU",[[-1,3378,"**"],[-1,3413,"**"]],[3389,3389],[3378,3411]]],[1564816069094,["GJX@GJXAIOU",[[-1,3248,"**"],[-1,3273,"**"]],[3258,3258],[3248,3271]]],[1564816082198,["GJX@GJXAIOU",[[-1,5116,"**"],[-1,5135,"**"]],[5125,5125],[5116,5133]]],[1564816085110,["GJX@GJXAIOU",[[-1,5200,"**"],[-1,5223,"**"]],[5208,5208],[5200,5221]]],[1564816088014,["GJX@GJXAIOU",[[-1,5490,"**"],[-1,5509,"**"]],[5501,5501],[5490,5507]]],[1564816090632,["GJX@GJXAIOU",[[-1,5492,"\\"]],[5493,5493],[5492,5492]]],[1564816091872,["GJX@GJXAIOU",[[1,5490,"### "]],[5492,5492],[5510,5510]]],[1564816096246,["GJX@GJXAIOU",[[-1,5738,"\\"]],[5739,5739],[5738,5738]]],[1564816097870,["GJX@GJXAIOU",[[-1,5734,"**"],[-1,5756,"**"]],[5738,5738],[5734,5754]]],[1564816099824,["GJX@GJXAIOU",[[1,5734,"### "]],[5734,5754],[5758,5758]]],[1564816107014,["GJX@GJXAIOU",[[1,5730,"\n"]],[5730,5730],[5731,5731]]],[1564816114510,["GJX@GJXAIOU",[[-1,5565,"\n"]],[5565,5565],[5564,5564]]],[1564816115223,["GJX@GJXAIOU",[[-1,5592,"\n"]],[5592,5592],[5591,5591]]],[1564816115902,["GJX@GJXAIOU",[[-1,5643,"\n"]],[5643,5643],[5642,5642]]],[1564816116582,["GJX@GJXAIOU",[[-1,5676,"\n"]],[5676,5676],[5675,5675]]],[1564816118310,["GJX@GJXAIOU",[[-1,5787,"\n"]],[5787,5787],[5786,5786]]],[1564816119009,["GJX@GJXAIOU",[[-1,5802,"\n"]],[5802,5802],[5801,5801]]],[1564816120808,["GJX@GJXAIOU",[[-1,5960,"\n"]],[5960,5960],[5959,5959]]],[1564816122046,["GJX@GJXAIOU",[[-1,6029,"\n"]],[6029,6029],[6028,6028]]],[1564816124526,["GJX@GJXAIOU",[[1,6104,"* \n"]],[6103,6103],[6106,6106]]],[1564816126734,["GJX@GJXAIOU",[[-1,6104,"* "]],[6106,6106],[6104,6104]]],[1564816127704,["GJX@GJXAIOU",[[1,6109,"\n"]],[6108,6108],[6109,6109]]],[1564816132233,["GJX@GJXAIOU",[[1,6109,"---"]],[6109,6109],[6112,6112]]],[1564816134648,["GJX@GJXAIOU",[[-1,6109,"---"]],[6109,6112],[6109,6109]]],[1564816137432,["GJX@GJXAIOU",[[-1,5867,"**"],[-1,5892,"**"]],[5872,5872],[5867,5890]]],[1564816139337,["GJX@GJXAIOU",[[1,5867,"### "]],[5867,5890],[5894,5894]]],[1564816141478,["GJX@GJXAIOU",[[-1,5873,"\\"]],[5874,5874],[5873,5873]]],[1564816145134,["GJX@GJXAIOU",[[-1,6115,"\\"]],[6116,6116],[6115,6115]]],[1564816849821,["GJX@GJXAIOU",[[-1,59,"答案"]],[61,61],[59,59]]],[1564816854047,["GJX@GJXAIOU",[[1,59,"Java"]],[59,59],[63,63]]],[1564816854082,["GJX@GJXAIOU",[[1,59," "]],[63,63],[64,64]]],[1564816855233,["GJX@GJXAIOU",[[1,64,"基础"]],[64,64],[66,66]]],[1564816855266,["GJX@GJXAIOU",[[1,64," "]],[66,66],[67,67]]],[1564816859711,["GJX@GJXAIOU",[[-1,83,"## 一、 Java 基础"]],[83,96],[83,83]]],[1564816864056,["GJX@GJXAIOU",[[-1,87,"#"]],[87,87],[107,107]]],[1564816867358,["GJX@GJXAIOU",[[-1,380,"#"]],[382,382],[403,403]]],[1564816873062,["GJX@GJXAIOU",[[-1,2806,"#"]],[2807,2807],[2847,2847]]],[1564816875039,["GJX@GJXAIOU",[[-1,3236,"#"]],[3236,3236],[3260,3260]]],[1564816876616,["GJX@GJXAIOU",[[-1,3361,"#"]],[3361,3361],[3395,3395]]],[1564816877541,["GJX@GJXAIOU",[[-1,3465,"#"]],[3464,3464],[3487,3487]]],[1564816878558,["GJX@GJXAIOU",[[-1,3583,"#"]],[3582,3582],[3614,3614]]],[1564816880287,["GJX@GJXAIOU",[[1,4020,"2"]],[4020,4020],[4021,4021]]],[1564816881782,["GJX@GJXAIOU",[[-1,4020,"2"]],[4021,4021],[4020,4020]]],[1564816882637,["GJX@GJXAIOU",[[-1,4021,"#"]],[4020,4020],[4071,4071]]],[1564816884030,["GJX@GJXAIOU",[[-1,4183,"#"]],[4184,4184],[4196,4196]]],[1564816886766,["GJX@GJXAIOU",[[-1,4596,"#"]],[4595,4595],[4619,4619]]],[1564816888478,["GJX@GJXAIOU",[[-1,4911,"#"]],[4910,4910],[4929,4929]]],[1564816890061,["GJX@GJXAIOU",[[-1,5096,"#"]],[5096,5096],[5114,5114]]],[1564816891047,["GJX@GJXAIOU",[[-1,5179,"#"]],[5179,5179],[5201,5201]]],[1564816892934,["GJX@GJXAIOU",[[-1,5472,"#"]],[5472,5472],[5489,5489]]],[1564816894439,["GJX@GJXAIOU",[[-1,5712,"#"]],[5711,5711],[5733,5733]]],[1564816895846,["GJX@GJXAIOU",[[-1,5847,"#"]],[5847,5847],[5870,5870]]],[1564816897182,["GJX@GJXAIOU",[[-1,6088,"#"]],[6088,6088],[6108,6108]]],[1564817261061,["GJX@GJXAIOU",[[-1,76,"* * *"]],[76,81],[76,76]]],[1564817263469,["GJX@GJXAIOU",[[-1,79,"\n"]],[78,78],[77,77]]],[1564817263654,["GJX@GJXAIOU",[[-1,78,"\n"]],[77,77],[76,76]]],[1564817263949,["GJX@GJXAIOU",[[-1,77,"\n"]],[76,76],[75,75]]],[1564817264679,["GJX@GJXAIOU",[[-1,76,"\n"]],[75,75],[74,74]]],[1564817979450,["GJX@GJXAIOU",[[-1,6072,"---"],[1,6075," "]],[6072,6075],[6072,6073]]],[1564817986061,["GJX@GJXAIOU",[[-1,364,"---"],[1,367," "]],[364,367],[364,365]]],[1564817986607,["GJX@GJXAIOU",[[-1,2787,"---"],[1,2790," "]],[2787,2790],[2787,2788]]],[1564817987081,["GJX@GJXAIOU",[[-1,3341,"---"],[1,3344," "]],[3341,3344],[3341,3342]]],[1564817987290,["GJX@GJXAIOU",[[-1,3443,"---"],[1,3446," "]],[3443,3446],[3443,3444]]],[1564817987474,["GJX@GJXAIOU",[[-1,3559,"---"],[1,3562," "]],[3559,3562],[3559,3560]]],[1564817987638,["GJX@GJXAIOU",[[-1,3995,"---"],[1,3998," "]],[3995,3998],[3995,3996]]],[1564817987809,["GJX@GJXAIOU",[[-1,4155,"---"],[1,4158," "]],[4155,4158],[4155,4156]]],[1564817988003,["GJX@GJXAIOU",[[-1,4566,"---"],[1,4569," "]],[4566,4569],[4566,4567]]],[1564817988665,["GJX@GJXAIOU",[[-1,4880,"---"],[1,4883," "]],[4880,4883],[4880,4881]]],[1564817989089,["GJX@GJXAIOU",[[-1,5062,"---"],[1,5065," "]],[5062,5065],[5062,5063]]],[1564817989465,["GJX@GJXAIOU",[[-1,5143,"---"],[1,5146," "]],[5143,5146],[5143,5144]]],[1564817990126,["GJX@GJXAIOU",[[-1,5435,"---"],[1,5438," "]],[5435,5438],[5435,5436]]],[1564817990726,["GJX@GJXAIOU",[[-1,5673,"---"],[1,5676," "]],[5673,5676],[5673,5674]]],[1564817991310,["GJX@GJXAIOU",[[-1,5806,"---"],[1,5809," "]],[5806,5809],[5806,5807]]]],null,"GJX@GJXAIOU"]]}