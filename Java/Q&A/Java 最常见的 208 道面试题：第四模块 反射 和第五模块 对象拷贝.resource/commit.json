{"compress":true,"commitItems":[["ff0bf3b1-715e-42e0-aa8d-c4384865630f",1563097832289,"## Java 最常见的 208 道面试题：第四模块和第五模块答案\n\n[Java团长](javascript:void(0);) _3月17日_\n\n## **第四模块答案**\n\n**反射**\n\n**57\\. 什么是反射？**\n\n反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力\n\n## Java反射：\n\n在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法\n\nJava反射机制主要提供了以下功能：\n\n*   在运行时判断任意一个对象所属的类。\n\n*   在运行时构造任意一个类的对象。\n\n*   在运行时判断任意一个类所具有的成员变量和方法。\n\n*   在运行时调用任意一个对象的方法。 \n\n**58\\. 什么是 java 序列化？什么情况下需要序列化？**\n\n简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。\n\n什么情况下需要序列化：\n\na）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；\nb）当你想用套接字在网络上传送对象的时候；\nc）当你想通过RMI传输对象的时候；\n\n**59\\. 动态代理是什么？有哪些应用？**\n\n动态代理：\n\n当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。\n\n动态代理的应用：\n\n*   Spring的AOP\n\n*   加事务\n\n*   加权限\n\n*   加日志\n\n**60\\. 怎么实现动态代理？**\n\n首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。\n\n* * *\n\n## **第五模块答案**\n\n**对象拷贝**\n\n**61\\. 为什么要使用克隆？**\n\n想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。\n\n**62\\. 如何实现对象克隆？**\n\n有两种方式：\n\n1). 实现Cloneable接口并重写Object类中的clone()方法；\n\n2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：\n\n```\nimport java.io.ByteArrayInputStream;\n```\n\n下面是测试代码：\n\n```\nimport java.io.Serializable;\n```\n\n```\n/**\n```\n\n```\nclass CloneTest {\n```\n\n注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。\n\n**63\\. 深拷贝和浅拷贝区别是什么？**\n\n*   浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）\n\n*   深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）",[[1563097807483,["GJX@GJXAIOU",[[1,1263,"\n"],[1,1299,"\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class MyUtil {\n\n    private MyUtil() {\n        throw new AssertionError();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends Serializable> T clone(T obj) throws Exception {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bout);\n        oos.writeObject(obj);\n\n        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());\n        ObjectInputStream ois = new ObjectInputStream(bin);\n        return (T) ois.readObject();\n\n        // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义\n        // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放\n    }\n}"]],[1263,1299],[2120,2120]]],[1563097820416,["GJX@GJXAIOU",[[1,2169,"\n/**\n * 人类\n * @author nnngu\n *\n */\nclass Person implements Serializable {\n    private static final long serialVersionUID = -9102017020286042305L;\n\n    private String name;    // 姓名\n    private int age;        // 年龄\n    private Car car;        // 座驾\n\n    public Person(String name, int age, Car car) {\n        this.name = name;\n        this.age = age;\n        this.car = car;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public Car getCar() {\n        return car;\n    }\n\n    public void setCar(Car car) {\n        this.car = car;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person [name=\" + name + \", age=\" + age + \", car=\" + car + \"]\";\n    }\n\n}\n"]],[2140,2168],[3049,3049]]],[1563097835137,["GJX@GJXAIOU",[[1,3059,"\n"],[1,3062,"\n * 小汽车类\n * @author nnngu\n *\n */\nclass Car implements Serializable {\n    private static final long serialVersionUID = -5713945027627603702L;\n\n    private String brand;       // 品牌\n    private int maxSpeed;       // 最高时速\n\n    public Car(String brand, int maxSpeed) {\n        this.brand = brand;\n        this.maxSpeed = maxSpeed;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public int getMaxSpeed() {\n        return maxSpeed;\n    }\n\n    public void setMaxSpeed(int maxSpeed) {\n        this.maxSpeed = maxSpeed;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car [brand=\" + brand + \", maxSpeed=\" + maxSpeed + \"]\";\n    }\n\n}"]],[3059,3062],[3806,3806]]],[1563097847504,["GJX@GJXAIOU",[[1,3834,"\n    public static void main(String[] args) {\n        try {\n            Person p1 = new Person(\"郭靖\", 33, new Car(\"Benz\", 300));\n            Person p2 = MyUtil.clone(p1);   // 深度克隆\n            p2.getCar().setBrand(\"BYD\");\n            // 修改克隆的Person对象p2关联的汽车对象的品牌属性\n            // 原来的Person对象p1关联的汽车不会受到任何影响\n            // 因为在克隆Person对象时其关联的汽车对象也被克隆了\n            System.out.println(p1);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"]],[3816,3834],[4301,4301]]],[1563097849890,["GJX@GJXAIOU",[[-1,3834,"\n    public static void main(String[] args) {\n        try {\n            Person p1 = new Person(\"郭靖\", 33, new Car(\"Benz\", 300));\n            Person p2 = MyUtil.clone(p1);   // 深度克隆\n            p2.getCar().setBrand(\"BYD\");\n            // 修改克隆的Person对象p2关联的汽车对象的品牌属性\n            // 原来的Person对象p1关联的汽车不会受到任何影响\n            // 因为在克隆Person对象时其关联的汽车对象也被克隆了\n            System.out.println(p1);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"]],[4301,4301],[3816,3834]]],[1563097853724,["GJX@GJXAIOU",[[1,3834,"\n    public static void main(String[] args) {\n        try {\n            Person p1 = new Person(\"郭靖\", 33, new Car(\"Benz\", 300));\n            Person p2 = MyUtil.clone(p1);   // 深度克隆\n            p2.getCar().setBrand(\"BYD\");\n            // 修改克隆的Person对象p2关联的汽车对象的品牌属性\n            // 原来的Person对象p1关联的汽车不会受到任何影响\n            // 因为在克隆Person对象时其关联的汽车对象也被克隆了\n            System.out.println(p1);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n"]],[3816,3833],[4301,4301]]]],null,"GJX@GJXAIOU"],["a6216deb-9562-4e52-9232-0137a42d6d56",1565072741146,"## Java 最常见的 208 道面试题：第四模块和第五模块答案\n\n[Java团长](javascript:void(0);) _3月17日_\n\n## **第四模块答案**\n\n**反射**\n\n**57\\. 什么是反射？**\n\n反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力\n\n## Java反射：\n\n在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法\n\nJava反射机制主要提供了以下功能：\n\n*   在运行时判断任意一个对象所属的类。\n\n*   在运行时构造任意一个类的对象。\n\n*   在运行时判断任意一个类所具有的成员变量和方法。\n\n*   在运行时调用任意一个对象的方法。 \n\n**58\\. 什么是 java 序列化？什么情况下需要序列化？**\n\n简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。\n\n什么情况下需要序列化：\n\na）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；\nb）当你想用套接字在网络上传送对象的时候；\nc）当你想通过RMI传输对象的时候；\n\n**59\\. 动态代理是什么？有哪些应用？**\n\n动态代理：\n\n当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。\n\n动态代理的应用：\n\n*   Spring的AOP\n\n*   加事务\n\n*   加权限\n\n*   加日志\n\n**60\\. 怎么实现动态代理？**\n\n首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。\n\n* * *\n\n## **第五模块答案**\n\n**对象拷贝**\n\n**61\\. 为什么要使用克隆？**\n\n想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。\n\n**62\\. 如何实现对象克隆？**\n\n有两种方式：\n\n1). 实现Cloneable接口并重写Object类中的clone()方法；\n\n2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：\n\n```\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class MyUtil {\n\n    private MyUtil() {\n        throw new AssertionError();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends Serializable> T clone(T obj) throws Exception {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bout);\n        oos.writeObject(obj);\n\n        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());\n        ObjectInputStream ois = new ObjectInputStream(bin);\n        return (T) ois.readObject();\n\n        // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义\n        // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放\n    }\n}\n```\n\n下面是测试代码：\n\n```\nimport java.io.Serializable;\n\n/**\n * 人类\n * @author nnngu\n *\n */\nclass Person implements Serializable {\n    private static final long serialVersionUID = -9102017020286042305L;\n\n    private String name;    // 姓名\n    private int age;        // 年龄\n    private Car car;        // 座驾\n\n    public Person(String name, int age, Car car) {\n        this.name = name;\n        this.age = age;\n        this.car = car;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public Car getCar() {\n        return car;\n    }\n\n    public void setCar(Car car) {\n        this.car = car;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person [name=\" + name + \", age=\" + age + \", car=\" + car + \"]\";\n    }\n\n}\n```\n\n```\n\n/**\n * 小汽车类\n * @author nnngu\n *\n */\nclass Car implements Serializable {\n    private static final long serialVersionUID = -5713945027627603702L;\n\n    private String brand;       // 品牌\n    private int maxSpeed;       // 最高时速\n\n    public Car(String brand, int maxSpeed) {\n        this.brand = brand;\n        this.maxSpeed = maxSpeed;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public int getMaxSpeed() {\n        return maxSpeed;\n    }\n\n    public void setMaxSpeed(int maxSpeed) {\n        this.maxSpeed = maxSpeed;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car [brand=\" + brand + \", maxSpeed=\" + maxSpeed + \"]\";\n    }\n\n}\n```\n\n```\nclass CloneTest {\n\n    public static void main(String[] args) {\n        try {\n            Person p1 = new Person(\"郭靖\", 33, new Car(\"Benz\", 300));\n            Person p2 = MyUtil.clone(p1);   // 深度克隆\n            p2.getCar().setBrand(\"BYD\");\n            // 修改克隆的Person对象p2关联的汽车对象的品牌属性\n            // 原来的Person对象p1关联的汽车不会受到任何影响\n            // 因为在克隆Person对象时其关联的汽车对象也被克隆了\n            System.out.println(p1);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。\n\n**63\\. 深拷贝和浅拷贝区别是什么？**\n\n*   浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）\n\n*   深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）",[[1565072693080,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1565072694039,["GJX@GJXAIOU",[[1,0,"---\nstyle: summer\ntags: [面试]\n---"]],[0,0],[32,32]]],[1565072696423,["GJX@GJXAIOU",[[-1,34,"#"]],[35,35],[34,34]]],[1565072698071,["GJX@GJXAIOU",[[-1,67,"[Java团长](javascript:void(0);) _3月17日_"]],[67,104],[67,67]]],[1565072699928,["GJX@GJXAIOU",[[-1,69,"## **第四模块答案**"]],[69,82],[69,69]]],[1565072712087,["GJX@GJXAIOU",[[-1,63,"答案"]],[65,65],[63,63]]],[1565072720204,["GJX@GJXAIOU",[[1,58,"f"],[-1,311," "],[1,312," "]],[58,58],[59,59]]],[1565072720317,["GJX@GJXAIOU",[[1,59,"a "]],[59,59],[60,60]]],[1565072720794,["GJX@GJXAIOU",[[1,60,"ns"]],[60,60],[62,62]]],[1565072721719,["GJX@GJXAIOU",[[-1,58,"fans"]],[62,62],[58,58]]],[1565072723618,["GJX@GJXAIOU",[[1,58,"反射"]],[58,58],[60,60]]],[1565072726235,["GJX@GJXAIOU",[[1,58," "]],[58,58],[59,59]]],[1565072731287,["GJX@GJXAIOU",[[-1,73,"**反射**"]],[73,79],[73,73]]],[1565072731751,["GJX@GJXAIOU",[[-1,74,"\n"]],[73,73],[72,72]]],[1565072734024,["GJX@GJXAIOU",[[1,69,"## "]],[69,69],[72,72]]],[1565072736095,["GJX@GJXAIOU",[[-1,69,"## "]],[72,72],[69,69]]],[1565072738363,["GJX@GJXAIOU",[[1,69,"@toc"]],[69,69],[73,73]]],[1565072741551,["GJX@GJXAIOU",[[-1,77,"\n"]],[76,76],[75,75]]],[1565072742015,["GJX@GJXAIOU",[[-1,76,"\n"]],[75,75],[74,74]]],[1565072746576,["GJX@GJXAIOU",[[-1,89,"**"]],[91,91],[89,89]]],[1565072748031,["GJX@GJXAIOU",[[-1,80,"\\"]],[81,81],[80,80]]],[1565072749200,["GJX@GJXAIOU",[[-1,76,"**"]],[76,78],[76,76]]],[1565072752281,["GJX@GJXAIOU",[[1,76,"## "]],[76,76],[89,89]]],[1565072766367,["GJX@GJXAIOU",[[1,126,"#"]],[126,126],[135,135]]],[1565072770600,["GJX@GJXAIOU",[[-1,312,"**"],[-1,343,"**"]],[317,317],[312,341]]],[1565072772751,["GJX@GJXAIOU",[[-1,557,"**"],[-1,578,"**"]],[567,567],[557,576]]],[1565072774768,["GJX@GJXAIOU",[[-1,778,"**"],[-1,794,"**"]],[788,788],[778,792]]],[1565072778095,["GJX@GJXAIOU",[[-1,1000,"**"],[-1,1008,"**"]],[1004,1004],[1000,1006]]],[1565072778969,["GJX@GJXAIOU",[[1,1014,"---\nstyle: summer\ntags: [面试]\n---"]],[1014,1014],[1046,1046]]],[1565072779012,["GJX@GJXAIOU",[[1,1048,"****"]],[1046,1046],[1048,1048]]],[1565072782475,["GJX@GJXAIOU",[[-1,1014,"---\nstyle: summer\ntags: [面试]\n---****"]],[1048,1048],[1014,1014]]],[1565072783858,["GJX@GJXAIOU",[[-1,1008,"**"],[-1,1014,"**"]],[1014,1014],[1008,1012]]],[1565072784617,["GJX@GJXAIOU",[[-1,1014,"**"],[-1,1030,"**"]],[1023,1023],[1014,1028]]],[1565072786032,["GJX@GJXAIOU",[[-1,1086,"**"],[-1,1102,"**"]],[1095,1095],[1086,1100]]],[1565072792976,["GJX@GJXAIOU",[[-1,4397,"**"],[-1,4417,"**"]],[4408,4408],[4397,4415]]],[1565072815676,["GJX@GJXAIOU",[[-1,559,"\\"],[1,560," "]],[559,560],[559,560]]],[1565072816736,["GJX@GJXAIOU",[[-1,780,"\\"],[1,781," "]],[780,781],[780,781]]],[1565072817368,["GJX@GJXAIOU",[[-1,1016,"\\"],[1,1017," "]],[1016,1017],[1016,1017]]],[1565072817923,["GJX@GJXAIOU",[[-1,1088,"\\"],[1,1089," "]],[1088,1089],[1088,1089]]],[1565072818781,["GJX@GJXAIOU",[[-1,4399,"\\"],[1,4400," "]],[4399,4400],[4399,4400]]],[1565072819565,["GJX@GJXAIOU",[[-1,314,"\\"],[1,315," "]],[314,315],[314,315]]],[1565072830000,["GJX@GJXAIOU",[[1,312,"## "]],[312,312],[344,344]]],[1565072833304,["GJX@GJXAIOU",[[1,560,"## "]],[560,560],[582,582]]],[1565072835401,["GJX@GJXAIOU",[[1,784,"## "]],[789,789],[801,801]]],[1565072837194,["GJX@GJXAIOU",[[1,1024,"2"]],[1024,1024],[1025,1025]]],[1565072838794,["GJX@GJXAIOU",[[-1,1024,"2"]],[1025,1025],[1024,1024]]],[1565072839097,["GJX@GJXAIOU",[[1,1023,"## "]],[1024,1024],[1040,1040]]],[1565072841500,["GJX@GJXAIOU",[[-1,1007,"#"]],[1008,1008],[1007,1007]]],[1565072845090,["GJX@GJXAIOU",[[-1,1016,"对象拷贝"]],[1016,1020],[1016,1016]]],[1565072846794,["GJX@GJXAIOU",[[-1,1012,"答案"]],[1014,1014],[1012,1012]]],[1565072848319,["GJX@GJXAIOU",[[1,1012," 对象拷贝"]],[1012,1012],[1017,1017]]],[1565072851697,["GJX@GJXAIOU",[[1,1096,"## "]],[1098,1098],[1113,1113]]],[1565072857640,["GJX@GJXAIOU",[[1,4416,"2"]],[4416,4416],[4417,4417]]],[1565072857669,["GJX@GJXAIOU",[[1,4416," "],[1,4417," "]],[4417,4417],[4418,4418]]],[1565072858951,["GJX@GJXAIOU",[[-1,4417,"2"]],[4418,4418],[4417,4417]]],[1565072859288,["GJX@GJXAIOU",[[1,4410,"## "]],[4417,4417],[4433,4433]]],[1565072861424,["GJX@GJXAIOU",[[-1,4420," "]],[4420,4420],[4419,4419]]],[1565072862655,["GJX@GJXAIOU",[[-1,4419," "]],[4420,4420],[4419,4419]]],[1565072873143,["GJX@GJXAIOU",[[-1,215,"\n"]],[215,215],[214,214]]],[1565072873809,["GJX@GJXAIOU",[[-1,237,"\n"]],[237,237],[236,236]]],[1565072874439,["GJX@GJXAIOU",[[-1,257,"\n"]],[257,257],[256,256]]],[1565072875046,["GJX@GJXAIOU",[[-1,285,"\n"]],[285,285],[284,284]]],[1565072877608,["GJX@GJXAIOU",[[-1,480,"\n"]],[480,480],[479,479]]],[1565072880273,["GJX@GJXAIOU",[[1,468,"**"],[1,479,"**"]],[468,479],[468,483]]],[1565072884664,["GJX@GJXAIOU",[[1,583,"**"],[1,588,"**"]],[583,588],[583,592]]],[1565072885810,["GJX@GJXAIOU",[[-1,593,"\n"]],[593,593],[592,592]]],[1565072889471,["GJX@GJXAIOU",[[1,733,"**"],[1,741,"**"]],[733,741],[733,745]]],[1565072890832,["GJX@GJXAIOU",[[-1,746,"\n"]],[746,746],[745,745]]],[1565072891905,["GJX@GJXAIOU",[[-1,761,"\n"]],[761,761],[760,760]]],[1565072892632,["GJX@GJXAIOU",[[-1,769,"\n"]],[769,769],[768,768]]],[1565072893858,["GJX@GJXAIOU",[[-1,777,"\n"]],[777,777],[776,776]]],[1565072898911,["GJX@GJXAIOU",[[-1,1001,"* * *"]],[1001,1006],[1001,1001]]],[1565072900671,["GJX@GJXAIOU",[[-1,1017,"\n"]],[1017,1017],[1016,1016]]],[1565072901175,["GJX@GJXAIOU",[[-1,1016,"\n"]],[1016,1016],[1015,1015]]],[1565072904008,["GJX@GJXAIOU",[[-1,1117,"\n"]],[1117,1117],[1116,1116]]],[1565072904922,["GJX@GJXAIOU",[[-1,1157,"\n"]],[1157,1157],[1156,1156]]],[1565072923680,["GJX@GJXAIOU",[[-1,124,"### "]],[124,128],[124,124]]],[1565072925698,["GJX@GJXAIOU",[[1,124,"**"],[1,131,"**"]],[124,131],[124,135]]],[1565072939613,["GJX@GJXAIOU",[[1,67," duixan"]],[67,67],[74,74]]],[1565072940647,["GJX@GJXAIOU",[[-1,68,"duixan"]],[74,74],[68,68]]],[1565072946674,["GJX@GJXAIOU",[[1,68,"对象拷贝"]],[68,68],[72,72]]],[1565072967261,["GJX@GJXAIOU",[[1,80,"# 第四模块 反射"]],[80,80],[89,89]]],[1565072969009,["GJX@GJXAIOU",[[1,90,"\n"]],[89,89],[90,90]]]],null,"GJX@GJXAIOU"]]}