{"compress":true,"commitItems":[["7461678f-7e3e-4851-9c73-059452edb4dc",1567432720869,"# Mybatis配置之元素详述\n\n2017年05月14日 21:10:54 [DreamMakers](https://me.csdn.net/andamajing) 阅读数 4866更多\n\n分类专栏： [Mybatis](https://blog.csdn.net/andamajing/article/category/6902012) [Mybatis应用及原理探析](https://blog.csdn.net/andamajing/article/category/6902014) [深入了解Mybatis使用及实现原理](https://blog.csdn.net/andamajing/article/category/9268791)\n\n[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循[ CC 4.0 BY-SA ](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明。\n\n本文链接：[https://blog.csdn.net/andamajing/article/details/72063702](https://blog.csdn.net/andamajing/article/details/72063702) \n\n在<[Mybatis配置之<environments>配置元素详述](http://blog.csdn.net/majinggogogo/article/details/71616712)>我们对<environments>元素配置进行了说明，而后通过两篇文章<[Mybatis中的数据源与连接池详解](http://blog.csdn.net/majinggogogo/article/details/71715846)><[Mybatis中的事务管理器详述](http://blog.csdn.net/majinggogogo/article/details/72026693)>分别对数据源和事务管理器进行了详述，从这篇文章起，我们继续来讲述mybatis配置文件中的其他元素配置项。今天，我们就来说说<typeHandlers>这个元素,看看是怎么使用的。\n\n我们都知道，mybatis为我们隐藏了很多操作数据库的代码，如在预处理语句PreparedStatement中设置一个参数，或是在执行完SQL语句后从结果集中取出数据。而这两个过程都需要合适的数据类型处理器来帮我们对数据进行正确的类型转换，在mybatis中又是谁帮我们在做这些事情呢？\n\n那就是<typeHandlers>元素了！\n\n我们还是从配置文件开始看起，来看看typeHandlers怎么配置。\n\n```\n<typeHandlers>      <!--           当配置package的时候，mybatis会去配置的package扫描TypeHandler          <package name=\"com.dy.demo\"/>       -->            <!-- handler属性直接配置我们要指定的TypeHandler -->      <typeHandler handler=\"\"/>            <!-- javaType 配置java类型，例如String, 如果配上javaType, 那么指定的typeHandler就只作用于指定的类型 -->      <typeHandler javaType=\"\" handler=\"\"/>            <!-- jdbcType 配置数据库基本数据类型，例如varchar, 如果配上jdbcType, 那么指定的typeHandler就只作用于指定的类型  -->      <typeHandler jdbcType=\"\" handler=\"\"/>            <!-- 也可两者都配置 -->      <typeHandler javaType=\"\" jdbcType=\"\" handler=\"\"/>        </typeHandlers>\n```\n\n 结合上面的配置，我们再看看mybatis源码中是怎么进行解析的。\n\n```\nprivate void typeHandlerElement(XNode parent) throws Exception {    if (parent != null) {      for (XNode child : parent.getChildren()) {        //子节点为package时，获取其name属性的值，然后自动扫描package下的自定义typeHandler        if (\"package\".equals(child.getName())) {          String typeHandlerPackage = child.getStringAttribute(\"name\");          typeHandlerRegistry.register(typeHandlerPackage);        } else {          //子节点为typeHandler时， 可以指定javaType属性， 也可以指定jdbcType, 也可两者都指定          //javaType 是指定java类型          //jdbcType 是指定jdbc类型（数据库类型： 如varchar）          String javaTypeName = child.getStringAttribute(\"javaType\");          String jdbcTypeName = child.getStringAttribute(\"jdbcType\");          //handler就是我们配置的typeHandler          String handlerTypeName = child.getStringAttribute(\"handler\");          //resolveClass方法就是我们上篇文章所讲的TypeAliasRegistry里面处理别名的方法          Class<?> javaTypeClass = resolveClass(javaTypeName);          //JdbcType是一个枚举类型，resolveJdbcType方法是在获取枚举类型的值          JdbcType jdbcType = resolveJdbcType(jdbcTypeName);          Class<?> typeHandlerClass = resolveClass(handlerTypeName);          //注册typeHandler, typeHandler通过TypeHandlerRegistry这个类管理          if (javaTypeClass != null) {            if (jdbcType == null) {              typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);            } else {              typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);            }          } else {            typeHandlerRegistry.register(typeHandlerClass);          }        }      }    }}\n```\n\n 从源码看，大的类型上支持两种方式，一种是包名的方式，另一种是只配置单个类型转换器。在解析的过程中，将配置的这些类型转换器都注册到typeHandlerRegistry中。其实，在mybatis中已经为我们事先注册好了绝大多数的类型转换器，可以满足我们绝大多数的使用场景。\n\n```\nprivate final Map<JdbcType, TypeHandler<?>> JDBC_TYPE_HANDLER_MAP = new EnumMap<JdbcType, TypeHandler<?>>(JdbcType.class);  private final Map<Type, Map<JdbcType, TypeHandler<?>>> TYPE_HANDLER_MAP = new HashMap<Type, Map<JdbcType, TypeHandler<?>>>();  private final TypeHandler<Object> UNKNOWN_TYPE_HANDLER = new UnknownTypeHandler(this);  private final Map<Class<?>, TypeHandler<?>> ALL_TYPE_HANDLERS_MAP = new HashMap<Class<?>, TypeHandler<?>>();   public TypeHandlerRegistry() {    register(Boolean.class, new BooleanTypeHandler());    register(boolean.class, new BooleanTypeHandler());    register(JdbcType.BOOLEAN, new BooleanTypeHandler());    register(JdbcType.BIT, new BooleanTypeHandler());     register(Byte.class, new ByteTypeHandler());    register(byte.class, new ByteTypeHandler());    register(JdbcType.TINYINT, new ByteTypeHandler());     register(Short.class, new ShortTypeHandler());    register(short.class, new ShortTypeHandler());    register(JdbcType.SMALLINT, new ShortTypeHandler());     register(Integer.class, new IntegerTypeHandler());    register(int.class, new IntegerTypeHandler());    register(JdbcType.INTEGER, new IntegerTypeHandler());     register(Long.class, new LongTypeHandler());    register(long.class, new LongTypeHandler());     register(Float.class, new FloatTypeHandler());    register(float.class, new FloatTypeHandler());    register(JdbcType.FLOAT, new FloatTypeHandler());     register(Double.class, new DoubleTypeHandler());    register(double.class, new DoubleTypeHandler());    register(JdbcType.DOUBLE, new DoubleTypeHandler());     register(Reader.class, new ClobReaderTypeHandler());    register(String.class, new StringTypeHandler());    register(String.class, JdbcType.CHAR, new StringTypeHandler());    register(String.class, JdbcType.CLOB, new ClobTypeHandler());    register(String.class, JdbcType.VARCHAR, new StringTypeHandler());    register(String.class, JdbcType.LONGVARCHAR, new ClobTypeHandler());    register(String.class, JdbcType.NVARCHAR, new NStringTypeHandler());    register(String.class, JdbcType.NCHAR, new NStringTypeHandler());    register(String.class, JdbcType.NCLOB, new NClobTypeHandler());    register(JdbcType.CHAR, new StringTypeHandler());    register(JdbcType.VARCHAR, new StringTypeHandler());    register(JdbcType.CLOB, new ClobTypeHandler());    register(JdbcType.LONGVARCHAR, new ClobTypeHandler());    register(JdbcType.NVARCHAR, new NStringTypeHandler());    register(JdbcType.NCHAR, new NStringTypeHandler());    register(JdbcType.NCLOB, new NClobTypeHandler());     register(Object.class, JdbcType.ARRAY, new ArrayTypeHandler());    register(JdbcType.ARRAY, new ArrayTypeHandler());     register(BigInteger.class, new BigIntegerTypeHandler());    register(JdbcType.BIGINT, new LongTypeHandler());     register(BigDecimal.class, new BigDecimalTypeHandler());    register(JdbcType.REAL, new BigDecimalTypeHandler());    register(JdbcType.DECIMAL, new BigDecimalTypeHandler());    register(JdbcType.NUMERIC, new BigDecimalTypeHandler());     register(InputStream.class, new BlobInputStreamTypeHandler());    register(Byte[].class, new ByteObjectArrayTypeHandler());    register(Byte[].class, JdbcType.BLOB, new BlobByteObjectArrayTypeHandler());    register(Byte[].class, JdbcType.LONGVARBINARY, new BlobByteObjectArrayTypeHandler());    register(byte[].class, new ByteArrayTypeHandler());    register(byte[].class, JdbcType.BLOB, new BlobTypeHandler());    register(byte[].class, JdbcType.LONGVARBINARY, new BlobTypeHandler());    register(JdbcType.LONGVARBINARY, new BlobTypeHandler());    register(JdbcType.BLOB, new BlobTypeHandler());     register(Object.class, UNKNOWN_TYPE_HANDLER);    register(Object.class, JdbcType.OTHER, UNKNOWN_TYPE_HANDLER);    register(JdbcType.OTHER, UNKNOWN_TYPE_HANDLER);     register(Date.class, new DateTypeHandler());    register(Date.class, JdbcType.DATE, new DateOnlyTypeHandler());    register(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler());    register(JdbcType.TIMESTAMP, new DateTypeHandler());    register(JdbcType.DATE, new DateOnlyTypeHandler());    register(JdbcType.TIME, new TimeOnlyTypeHandler());     register(java.sql.Date.class, new SqlDateTypeHandler());    register(java.sql.Time.class, new SqlTimeTypeHandler());    register(java.sql.Timestamp.class, new SqlTimestampTypeHandler());     // mybatis-typehandlers-jsr310    try {      // since 1.0.0      register(\"java.time.Instant\", \"org.apache.ibatis.type.InstantTypeHandler\");      register(\"java.time.LocalDateTime\", \"org.apache.ibatis.type.LocalDateTimeTypeHandler\");      register(\"java.time.LocalDate\", \"org.apache.ibatis.type.LocalDateTypeHandler\");      register(\"java.time.LocalTime\", \"org.apache.ibatis.type.LocalTimeTypeHandler\");      register(\"java.time.OffsetDateTime\", \"org.apache.ibatis.type.OffsetDateTimeTypeHandler\");      register(\"java.time.OffsetTime\", \"org.apache.ibatis.type.OffsetTimeTypeHandler\");      register(\"java.time.ZonedDateTime\", \"org.apache.ibatis.type.ZonedDateTimeTypeHandler\");      // since 1.0.1      register(\"java.time.Month\", \"org.apache.ibatis.type.MonthTypeHandler\");      register(\"java.time.Year\", \"org.apache.ibatis.type.YearTypeHandler\");     } catch (ClassNotFoundException e) {      // no JSR-310 handlers    }     // issue #273    register(Character.class, new CharacterTypeHandler());    register(char.class, new CharacterTypeHandler());  }\n```\n\n 我们可以发现这些注册了的类型转换器都继承自BaseTypeHandler，如果现有的类型注册器不能满足需求，那么就需要我们根据需要自己进行定制，而定制的类型转换器都必须继承BaseTypeHandler。我们先看看这个基类的源码实现：\n\n```\npublic abstract class BaseTypeHandler<T> extends TypeReference<T> implements TypeHandler<T> {   protected Configuration configuration;   public void setConfiguration(Configuration c) {    this.configuration = c;  }   @Override  public void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException {    if (parameter == null) {      if (jdbcType == null) {        throw new TypeException(\"JDBC requires that the JdbcType must be specified for all nullable parameters.\");      }      try {        ps.setNull(i, jdbcType.TYPE_CODE);      } catch (SQLException e) {        throw new TypeException(\"Error setting null for parameter #\" + i + \" with JdbcType \" + jdbcType + \" . \" +                \"Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. \" +                \"Cause: \" + e, e);      }    } else {      try {        setNonNullParameter(ps, i, parameter, jdbcType);      } catch (Exception e) {        throw new TypeException(\"Error setting non null for parameter #\" + i + \" with JdbcType \" + jdbcType + \" . \" +                \"Try setting a different JdbcType for this parameter or a different configuration property. \" +                \"Cause: \" + e, e);      }    }  }   @Override  public T getResult(ResultSet rs, String columnName) throws SQLException {    T result;    try {      result = getNullableResult(rs, columnName);    } catch (Exception e) {      throw new ResultMapException(\"Error attempting to get column '\" + columnName + \"' from result set.  Cause: \" + e, e);    }    if (rs.wasNull()) {      return null;    } else {      return result;    }  }   @Override  public T getResult(ResultSet rs, int columnIndex) throws SQLException {    T result;    try {      result = getNullableResult(rs, columnIndex);    } catch (Exception e) {      throw new ResultMapException(\"Error attempting to get column #\" + columnIndex+ \" from result set.  Cause: \" + e, e);    }    if (rs.wasNull()) {      return null;    } else {      return result;    }  }   @Override  public T getResult(CallableStatement cs, int columnIndex) throws SQLException {    T result;    try {      result = getNullableResult(cs, columnIndex);    } catch (Exception e) {      throw new ResultMapException(\"Error attempting to get column #\" + columnIndex+ \" from callable statement.  Cause: \" + e, e);    }    if (cs.wasNull()) {      return null;    } else {      return result;    }  }   public abstract void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;   public abstract T getNullableResult(ResultSet rs, String columnName) throws SQLException;   public abstract T getNullableResult(ResultSet rs, int columnIndex) throws SQLException;   public abstract T getNullableResult(CallableStatement cs, int columnIndex) throws SQLException; }\n```\n\n 从上面的源码可以看出来，核心的代码已经实现了，如怎么给预处理语句设置参数，怎么从查询结果集中获取数据。在基类中还有四个抽象方法，具体的类型转换器只需要实现这四个方法就可以了。如下面我们定义一个类型转换器用于对VARCHAR类型数据进行处理。类型转换器定义如下：\n\n```\n@MappedJdbcTypes(JdbcType.VARCHAR)  //此处如果不用注解指定jdbcType, 那么，就可以在配置文件中通过\"jdbcType\"属性指定， 同理， javaType 也可通过 @MappedTypes指定public class ExampleTypeHandler extends BaseTypeHandler<String> {   @Override  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {    ps.setString(i, parameter);  }   @Override  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {    return rs.getString(columnName);  }   @Override  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {    return rs.getString(columnIndex);  }   @Override  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {    return cs.getString(columnIndex);  }}\n```\n\n 然后我们只需要在配置文件中配置一下就可以了，如下所示：\n\n```\n<typeHandlers>      <!-- 由于自定义的TypeHandler在定义时已经通过注解指定了jdbcType, 所以此处不用再配置jdbcType -->      <typeHandler handler=\"ExampleTypeHandler\"/>  </typeHandlers>\n```\n\n 备注说明：可以在类型转换器定义的时候通过@MappedJdbcTypes指定jdbcType, 通过 @MappedTypes 指定javaType, 如果没有使用注解指定，那么我们就需要在配置文件中配置。\n\n至此，关于<typeHandlers>元素的配置知识便描述的差不多了，感兴趣的朋友可以自己研究研究。",[[1567432686290,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1567432687547,["GJX@GJXAIOU",[[1,0,"---\ntag:\n- 未看\nflag: yellow\n---"]],[0,0],[30,30]]]],null,"GJX@GJXAIOU"]]}